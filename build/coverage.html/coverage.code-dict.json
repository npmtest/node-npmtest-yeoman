{"/home/travis/build/npmtest/node-npmtest-yeoman/test.js":"/* istanbul instrument in package npmtest_yeoman */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yeoman/lib.npmtest_yeoman.js":"/* istanbul instrument in package npmtest_yeoman */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_yeoman = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_yeoman = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-yeoman/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-yeoman && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_yeoman */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_yeoman\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_yeoman.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_yeoman.rollup.js'] =\n            local.assetsDict['/assets.npmtest_yeoman.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_yeoman.__dirname + '/lib.npmtest_yeoman.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/yeoman.js":"\n\nvar yeoman = module.exports;\n\n//\n// custom package utilities, works in tandem with `grunt.util`.\n//\n// Utils is there to package and provide a\n//\n// Will be merged into grunt.util for further usage in tasks and helpers\n//\nyeoman.utils = require('./lib/utils');\n\n// Yeoman generators\nyeoman.generators = require('yeoman-generators');\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/lib/utils/index.js":"\nvar path = require('path');\n\nvar utils = module.exports;\n\n//\n// flatiron/utile inspired.\n//\n// Set of common utilities, mainly defining wrapper to various utility modules\n// (like mkdir, rimraf) as lazy-loaded getters.\n\n\nObject.defineProperties( utils,\n  [\n    // Wrapper to `require('mkdirp')`\n    'mkdirp',\n    // Wrapper to `require('rimraf')`\n    'rimraf',\n    // Wrapper to `require('./fetch')`, internal tarball helper using\n    // mikeal/request, zlib and isaacs/tar.\n    './fetch'\n  ].reduce(function( descriptor, api ) {\n    return (\n      // Add the Identifier and define a get accessor that returns\n      // a fresh or cached copy of the API; remove any\n      // non-alphanumeric characters (in the case of \"./fetch\")\n      descriptor[ api.replace(/\\W/g, '') ] = {\n        get: function() { return require(api); }\n      },\n      // Return the |descriptor| object at the end of the expression,\n      // continuing the the reduction.\n      descriptor\n    );\n    // Prime the \"initialVal\" with an empty object\n  }, {})\n);\n\n\n// **extend** a given object with the util module definition, taking care\n// of not triggering the getters. Doing so with _.extend makes the module\n// to be required right away.\nutils.extend = function extend(o) {\n  Object.keys(utils).forEach(function(prop) {\n    Object.defineProperty(o, prop, {\n      get: function() {\n        return utils[prop];\n      }\n    });\n  });\n  return o;\n};\n\n//\n// **join** basic wrapper to `path.join`, dealing with `//` and converting back\n// **`\\` windows like path to unix like one.\n//\nutils.join = function join() {\n  var args = Array.prototype.slice.call(arguments);\n  return path.join.apply(path, args).replace(/\\\\/g, '/');\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/bin/yeoman":"#!/usr/bin/env node\nvar fs = require('fs'),\n  exec = require('child_process').exec,\n  join = require('path').join,\n  grunt = require('grunt'),\n  colors = require('colors'),\n  path = require('path'),\n  prompt = require('prompt'),\n  insight = require('../lib/plugins/insight.js'),\n  updater = require('../lib/plugins/updater.js'),\n  yeoman = require('../'),\n  pkg = require('../package.json'),\n  _ = grunt.util._,\n  async = grunt.util.async,\n  compiled = _.template( fs.readFileSync( join(__dirname, 'help.txt'), 'utf8' ));\n\n\n// Returns the user's home directory in a platform agnostic way.\nfunction getUserHome() {\n  return process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];\n}\n\nfunction init() {\n  // grunt with the plugin registered\n  grunt.npmTasks(join(__dirname, '../'));\n\n  // Get back a reference to the internal grunt cli object so that we can read\n  // command line parsed options from grunt, to run our internal additional\n  // logic.\n\n  var cli =  require('grunt/lib/grunt/cli');\n\n  // avoid the deprecation notice: goo.gl/mk2De\n  Object.defineProperty(grunt, 'utils', {\n    get: function() {\n      return grunt.util;\n    }\n  });\n\n  // command line options and remaining args\n  var opts = cli.options,\n    cmds = cli.tasks,\n    route = cmds.join(' ').trim('');\n\n  // Flag to disable Insight. Intended for devs to use while testing the cli\n  // so inflated stats are no recorded.\n  if (/--disable-insight/.test(process.argv)) {\n    process.env.no_stats = true;\n  }\n\n  // custom help, on `h5bp help`\n  if(/^help/.test(route)) {\n    if(/^help$/.test(route)) {\n\n      if (!process.env.no_stats) {\n        // Tell Insight \"help\" was run.\n        insight.init({\n          pkgname    : pkg.name,\n          pkgversion : pkg.version,\n          getUserHome: getUserHome,\n          cmds       : cmds,\n          cb         : function() {}\n        });\n      }\n\n      return console.log( compiled() );\n    }\n    cli.tasks = cmds.join(':');\n  }\n\n  // specific flag to ensure we bypass insight prompt when running the test task\n  if(/^test/.test(route)) {\n    var env = process.env;\n    env.yeoman_test = true;\n  }\n\n  // add the plugin version on `--version`\n  if(opts.version) {\n    return console.log( pkg.version );\n  }\n\n  // Matches everything after init to prevent\n  // the user from seeing the default grunt init tasks\n  if(/^init/.test(route)) {\n    // required handling of options / arguments to workaround some internal check\n    // of Grunt, and let the generators go through (init and invoked in our front\n    // Grunt template)\n    yeoman.generators.prepare(grunt);\n  }\n\n  // Advice users to run `server` instead of `watch`\n  if ( /^watch/.test( route ) ) {\n    console.log(('\\nFYI: Yeoman`s watch task is integrated within ' +\n      'yeoman server'.bold + ' to combine the dev server, re-compilation and ' +\n      'live reloading of changed assets.\\n\\nContinuing anyway...\\n').yellow);\n  }\n\n  // a bower command\n  // Examples:\n  // yeoman install jquery\n  // yeoman install spine\n  // yeoman install backbone (which does jquery etc too.)\n  // yeoman update spine\n  // yeoman lookup jquery\n  // yeoman search jquery\n  if(/^install|^uninstall|^search|^list|^ls|^lookup|^update/.test(route)) {\n    cli.tasks = 'bower' + ':' + cmds.join(':');\n  }\n\n\n  /* Yeoman Insight =========================================================== */\n  async.series([function(cb) {\n\n    // Are we dealing with yeoman in a test environment? If so, skip the\n    // insight prompt. This is specifically put into the environment by\n    // our test spawn helper.\n    if(process.env.yeoman_test || process.env.no_stats) {\n      return cb();\n    }\n\n    insight.init({\n      pkgname    : pkg.name,\n      pkgversion : pkg.version,\n      getUserHome: getUserHome,\n      cmds       : cmds,\n      cb         : cb\n    });\n\n  }, function(cb) {\n\n    // if the route is empty\n    if(/^$/.test(route)) {\n      // this is specific to an empty route code\n      console.log(pkg.name + ' v%s', pkg.version);\n\n      // we return early to prevent grunt from actually running\n      // and instead just output help.txt\n      cb();\n      return console.log( compiled() );\n    }\n\n    // the grunt cli\n    grunt.cli();\n\n    cb();\n\n  }]);\n}\n\ninit();\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/Gruntfile.js":"var util = require('util');\nvar path = require('path');\n\nmodule.exports = function( grunt ) {\n  'use strict';\n\n  grunt.initConfig({\n    lint: {\n      options: {\n        options: '<json:.jshintrc>',\n        global: {\n          process: true\n        }\n      },\n      grunt: [\n        'Gruntfile.js',\n        //'tasks/*.js',\n      ],\n      lib: [\n        //'lib/{plugins,utils}/*.js',\n        //'lib/generators/*.js'\n      ],\n      test: [\n        //'test/**/*.js'\n      ]\n    },\n    watch: {\n      files: '<config:lint>',\n      tasks: 'lint'\n    }\n  });\n\n  // Disable lint for now until we upgrade to latest grunt with latest jshint\n  grunt.registerTask( 'default', 'lint' );\n\n  // Debugging helpers\n  grunt.registerTask( 'list-helpers', 'List all grunt registered helpers', function( helper ) {\n    var ls = grunt.log.wordlist( Object.keys( grunt.task._helpers ), grunt.util.linefeed );\n\n    if ( !helper ) {\n      return grunt.log.ok( ls );\n    }\n\n    grunt.log.subhead( helper + ' source:' ).writeln( grunt.task._helpers[ helper ] );\n  });\n\n  grunt.registerTask( 'list-tasks', 'List all grunt registered tasks', function( task ) {\n    var ls = grunt.log.wordlist( Object.keys( grunt.task._tasks ), grunt.util.linefeed );\n\n    if ( !task ) {\n      return grunt.log.ok( ls );\n    }\n\n    grunt.log.subhead( task + ' source:' ).writeln( util.inspect( grunt.task._tasks[ task ] ) );\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/bower.js":"\nvar path     = require('path');\nvar fs       = require('fs');\nvar bower    = require('bower');\nvar template = require('bower/lib/util/template');\nvar shelljs  = require('shelljs');\n\n\nmodule.exports = function(grunt) {\n\n  // Task facade to Twitter Bower.\n  //\n  // This task basically just pases our current provess.argv to bower. Special tasks\n  // like install, list, search etc. are all configured to trigger this one.\n  //\n  // A yeoman-specific configuration can be defined in your Gruntfile:\n  //\n  // - dir: Alternate directory location. (defaults to: components)\n  //\n  // If the dir option is specified, bower is asked for the package dependency\n  // model and each paths. Each package is then simply copied over the value of\n  // the dir options.\n  //\n  // `components/` next to your Gruntfile is bower's internal directory.\n  // `app/js/vendor` is your working directory, files used in development and\n  // concat / min by grunt script.\n  grunt.registerTask('bower', 'This triggers the `bower` commands.', function() {\n    // pull in the bower command module\n    var args = this.args;\n    var command = bower.commands[args[0]];\n    if(!command) {\n      return grunt.fatal('A valid bower command should be specified.');\n    }\n\n    // figure out the alternate install location, if any\n    var directory = grunt.config('bower.dir');\n\n    // run\n    var cb = this.async();\n    command.line(process.argv)\n      .on('error', grunt.fatal.bind(grunt.fail))\n      .on('data', grunt.log.writeln.bind(grunt.log))\n      .on('end', function(){\n\n        grunt.helper('bower:sync', directory, cb);\n        /*\n        if(args[0] === 'install' && directory) {\n          grunt.helper('bower:sync', directory, cb);\n        } else if(args[0] === 'uninstall' || args[0] === 'update' && directory) {\n          grunt.helper('bower:sync', directory, cb);\n        } else {\n          cb();\n        }*/\n      });\n  });\n\n\n  // This helper returns a function meant to be used as a direct callback, most\n  // likely on the end event of a bower command.\n  //\n  // Bower's list is used to get the paths of each dependency in\n  // components/, these deps are simply copied over the directory\n  // specified.\n  //\n  // - dir: directory path to mirror bower's components.\n  // - cb: callback to call on completion.\n  //\n  // Examples:\n  //\n  //      stuff.on('end', grunt.helper('bower:copy', this.async()));\n  //\n  grunt.registerHelper('bower:copy', function(dir, cb) {\n    if(typeof cb !== 'function') {\n      return grunt.fatal('bower:copy helper requires a callback.');\n    }\n\n    if(!dir) {\n      return grunt.fatal('bower:copy helper requires a directory path.');\n    }\n\n    // Resolve application index\n    var scripts = '';\n    var basePath = 'app';\n    var appIndexPath  = path.resolve(path.join(basePath + '/index.html'));\n    var indexBuffer = fs.readFileSync(appIndexPath, 'utf8');\n\n    // parse data-main for require config path\n    var datamain = /data-main=['\"]([^'\"]+)['\"]/;\n\n    // Syncronize the components directory with the vendor directory\n    // if we're not having an rjs setup, go through synchronize step directly\n    if(!datamain.test(indexBuffer)){\n      return grunt.helper('bower:sync', dir, cb);\n    }\n\n    // store the relative filepath of the rjs entry point\n    var filepath = indexBuffer.match(datamain)[1];\n\n    // otherwise, request bower for deps listing and update the relevant config\n    // while going through to synchronize step when done\n    bower.commands.list({ paths: true })\n      .on('error', grunt.fatal.bind(grunt.fail))\n      .on('data', function(deps) {\n        // should probably emit on `end` in bower's internal\n        if(typeof deps === 'string') { return; }\n\n        // Handler for RequireJS app config.\n        // Wires up the relevant RequireJS paths config when\n        // running `yeoman install spine backbone` etc.\n\n        var requireConfigPath = basePath + '/' + filepath;\n\n        // check path contains .js, append if not\n        if ( requireConfigPath.indexOf('.js') ) {\n          requireConfigPath += '.js';\n        }\n\n        // check config file exists\n        var configExists = grunt.file.exists(requireConfigPath);\n        if(configExists) {\n          grunt.helper('bower:log', 'Updating RequireJS config: ' + requireConfigPath);\n          // if so..\n          // iterate over Bower deps, generating the path string fo config\n          Object.keys(deps).forEach(function(dep){\n            // Quote key if it contains non a-z chars\n            var key = /[^\\w]/.test( dep ) ? '\\'' + dep + '\\'' : dep;\n            scripts+= \"    \" + key + \": '../../\" + deps[dep].replace('.js','') + \"',\\n\";\n          });\n\n          // read in the existing data-main config\n          var cf = fs.readFileSync(requireConfigPath, 'utf8');\n          // replace the existing paths with your new paths\n          var html = cf.replace(' paths: {', 'paths: {\\n' + scripts);\n\n          // Write the paths to config\n          fs.writeFileSync(requireConfigPath, html, 'utf8');\n        }\n\n        // end the process\n        grunt.helper('bower:sync', dir, cb);\n      });\n  });\n\n\n\n  // Helper to syncronize the Bower components directory with app/scripts/vendor\n  grunt.registerHelper('bower:sync', function(dir, cb) {\n    // Clean the vendor directory then sync with the components directory\n\n    if(typeof cb !== 'function') {\n      return grunt.fatal('bower:sync helper requires a callback.');\n    }\n\n    if(!dir) {\n      return grunt.fatal('bower:sync helper requires a directory path.');\n    }\n\n    shelljs.rm('-rf', dir);\n    shelljs.mkdir('-p', dir);\n    shelljs.cp('-R', 'components/*', dir);\n\n    cb();\n  });\n\n  // Little grunt helper to access the bower template facility.\n  //\n  // - name       - a String to define the template name to invoke\n  // - context    - A hash of data to pass through the given template\n  //\n  // Returns the template output\n  grunt.registerHelper('bower:template', function(name, context) {\n    return template(name, context, true);\n  });\n\n  // Helper to log through bower template action utility.\n  //\n  // - name   - main message.\n  // - stuff  - additional logging message. Displayed in grey.\n  grunt.registerHelper('bower:log', function(name, stuff) {\n    grunt.log.writeln(grunt.helper('bower:template', 'action', {\n      name: name,\n      shizzle: stuff\n    }));\n  });\n};","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/compass.js":"module.exports = function( grunt ) {\n  'use strict';\n\n  var _ = grunt.util._;\n\n  function optsToArgs( opts ) {\n    var args = [];\n\n    Object.keys( opts ).forEach(function( el ) {\n      var val = opts[ el ];\n\n      el = el.replace( /_/g, '-' );\n\n      if ( val === true ) {\n        args.push( '--' + el );\n      }\n\n      if ( _.isString( val ) ) {\n        args.push( '--' + el, val );\n      }\n\n      if( _.isArray( val ) ) {\n        val.forEach(function( subval ) {\n          args.push( '--' + el, subval );\n        });\n      }\n    });\n\n    return args;\n  }\n\n  grunt.registerMultiTask( 'compass', 'Compass task', function() {\n    var cb = this.async();\n    var args = optsToArgs( this.options() );\n\n    var compass = grunt.util.spawn({\n      cmd: 'compass',\n      args: ['compile'].concat( args )\n    }, function( err, result, code ) {\n      if ( /not found/.test( err ) ) {\n        grunt.fail.fatal('You need to have Compass installed.');\n      }\n      // Since `compass compile` exits with 1 when it has nothing to compile,\n      // we do a little workaround by checking stdout which is then empty\n      // https://github.com/chriseppstein/compass/issues/993\n      cb( code === 0 || !result.stdout );\n    });\n\n    compass.stdout.pipe( process.stdout );\n    compass.stderr.pipe( process.stderr );\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/css.js":"\nvar fs = require('fs'),\n  path = require('path'),\n  cleanCSS = require('clean-css'),\n  rjs = require('requirejs');\n\nmodule.exports = function(grunt) {\n\n\n\n  // **css* task works pretty much the same as grunt's min task. The task\n  // target is the destination, data is an array of glob patterns. These\n  // files are concataned and run through requirejs optimizer to handle\n  // @import inlines in CSS files.\n  grunt.task.registerMultiTask('css', 'Concats, replaces @imports and minifies the CSS files', function() {\n    this.requiresConfig('staging');\n\n    // if defined, files get prepended by the output config value\n    var files = this.data;\n\n    // subtarget name is the output destination\n    var target = this.target;\n\n    // async task\n    var cb = this.async();\n\n    // concat prior to rjs optimize css, and before min max info\n    grunt.log.write('Writing css files to ' + target + '...');\n    var out = grunt.helper('mincss', files);\n    // only go through if their's file to process\n    if(!out) {\n      return cb();\n    }\n\n    // write minified file before going through rjs:optimize to possibly inline\n    // @imports (that are not handled by compass within .scss or .sass files)\n    grunt.file.write(target, out);\n\n    // replace @import statements\n    //\n    // XXX no error handling in this helper so far..\n    // Check that rjs returns an error when something wrong (if it throws...)\n    // if it is bubble the error back here\n    grunt.helper('rjs:optimize:css', target, function() {\n      // do the minification once inline imports are done\n      grunt.log.ok();\n      cb();\n    });\n  });\n\n  //\n  // **mincss** basic utility to concat CSS files and run them through\n  // [cleanCSS](https://github.com/GoalSmashers/clean-css), might opt to use\n  // [https://github.com/jzaefferer/grunt-css] plugin.\n  //\n  grunt.registerHelper('mincss', function(files, o) {\n    o = o || {};\n    files = grunt.file.expandFiles(files);\n    return files.map(function(filepath) {\n      var content = grunt.file.read(filepath);\n      return o.nocompress ? content : cleanCSS.process(content);\n    }).join('');\n  });\n\n  // **rjs:optimize:css** is an helper using rjs to optimize a single file,\n  // mainly to properly import multi-level of @import statements, which can be\n  // tricky with all the url rewrites.\n  //\n  // file     - Path to the css file to optimize\n  // options  - (optional) rjs configuration\n  // cb       - callback function to call on completion\n  grunt.registerHelper('rjs:optimize:css', function(file, options, cb) {\n    if(!cb) { cb = options; options = {}; }\n    options.cssIn = file;\n    options.out = options.out || file;\n    options.optimizeCss = 'standard.keepComments.keepLines';\n    var before = grunt.file.read(file);\n    rjs.optimize(options, function() {\n      grunt.helper('min_max_info', grunt.file.read(file), before);\n      cb();\n    });\n  });\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/html.js":"\nvar path = require('path'),\n  minifier = require('html-minifier');\n\n//\n// This task takes care of html minification through @kangax' html-minifier\n// project\n//\n// > http://perfectionkills.com/experimenting-with-html-minifier/\n//\n// This is not a multi-task, but a simple one. The configuration is as follow:\n//\n//      ...\n//      html: {\n//        files: ['**/*.html']\n//        options: {\n//          ...\n//        }\n//      }\n//      ...\n//\n// Usage:\n//\n//      grunt html:<type>\n//\n// Three \"types\" of html compression are supported. They map the html\n// options of h5bp/ant-build-script, except that types and configuration works\n// in \"reverse order\" here. (eg. default type is most aggresive compression).\n// And we at the moment only have two types of html compression.\n//\n// * compress: (when `grunt html` or `grunt html:compress` is run)\n//   Agrresive html compression (Most advanced optimization configuration,\n//   Full html minification)\n//\n// * buildkit: (when `grunt html:buildkit` is run)\n//   all html whitespace/comments maintained (todo: inline and minify\n//   style/script)\n//\n// * basics: (when `grunt html:basics` is run) Intermediate html compression\n//   (whitespace removed / comments removed)\n//\n// One very last thing this tasks needs to do is the minification of\n// inlined styles / scripts.\n//\n//\n\nvar options = {\n  // maintaining whitespace, removing html comments, extra quotes\n  // removed, ...\n  basics: {\n    collapseWhitespace: false\n  },\n\n  // maintaining whitespace, retain html comments\n  buildkit: {\n    collapseWhitespace            : false,\n    removeComments                : false,\n    removeCommentsFromCDATA       : false\n  },\n\n  compress: {\n    removeComments                : true,\n    removeCommentsFromCDATA       : true,\n    removeEmptyAttributes         : true,\n    cleanAttributes               : true,\n    removeAttributeQuotes         : true,\n    removeRedundantAttributes     : true,\n    removeScriptTypeAttributes    : true,\n    removeStyleLinkTypeAttributes : true,\n    collapseWhitespace            : true,\n    collapseBooleanAttributes     : true,\n    removeOptionalTags            : true\n  }\n};\n\nmodule.exports = function(grunt) {\n\n  grunt.registerTask('html', 'Basic to aggresive html minification', function(type) {\n    var config = grunt.config('html') || {};\n    grunt.config.requires('html.files', 'staging');\n\n    grunt.log.writeln('Run htmlcompressor on ' + grunt.log.wordlist(config.files));\n\n    // default type\n    type = type || config.type || 'compress';\n\n    var valid = Object.keys( options ).indexOf( type ) !== -1;\n\n    if ( !valid ) {\n      return grunt.log.error( 'not a valid target: ' + type );\n    }\n\n    // merge default options for predefined type with the grunt's config\n    // one.\n    var defaults = options.compress;\n    grunt.util._.defaults(options[type], defaults);\n\n    grunt.log\n      .write('>> ' + type + '... ')\n      .subhead('Options:')\n      .writeln(grunt.helper('inspect', options[type]));\n\n    var files = grunt.file.expandFiles(config.files).map(function(file) {\n      var body = grunt.file.read(file);\n      return {\n        file: file,\n        body: body,\n        minified: grunt.helper('html', body, options[type])\n      };\n    });\n\n    // now write back to the disk each optimized html file\n    files.forEach(function(file) {\n      grunt.log.subhead(file.file);\n      grunt.helper('min_max_info', file.minified, file.body);\n      grunt.file.write(file.file, file.minified);\n    });\n  });\n\n  //\n  // **html** helper is a wrapper to html-minifier package, taking care of\n  // html compression. See below for the full list of possible options. Options\n  // may be setup using `grunt.config('html.options')` in your gruntfile.\n  //\n  grunt.registerHelper('html', function(body, opts) {\n    opts = opts || {};\n\n    // > http://perfectionkills.com/experimenting-with-html-minifier/#options\n    grunt.util._.defaults(opts, grunt.config('html.options'), {\n      removeComments: true,\n      removeCommentsFromCDATA: true,\n      removeEmptyAttributes: true,\n      cleanAttributes: true,\n      removeAttributeQuotes: true,\n      removeRedundantAttributes: true,\n      removeScriptTypeAttributes: true,\n      removeStyleLinkTypeAttributes: true,\n      collapseWhitespace: true,\n      collapseBooleanAttributes: true,\n      removeOptionalTags: true\n    });\n\n    return minifier.minify(body, opts);\n  });\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/img.js":"\nvar fs = require('fs'),\n  path = require('path'),\n  which = require('which');\n\n//\n// This task takes care of img optimizations by running a set of `.png`\n// or `.jpg` files through optipng and jpegtran.\n//\n//      grunt img:<type>\n//\n// Gruntfile config:\n//\n//      ...\n//      img: {\n//        src: ['img/**/*'],\n//        options: {\n//          ...\n//        }\n//      }\n//\n\nvar win32 = process.platform === 'win32';\n\nmodule.exports = function(grunt) {\n\n  var png = ['.png'],\n    jpegs = ['.jpg', 'jpeg'];\n\n  // rev task - reving is done in the `output/` directory\n  grunt.registerMultiTask('img', 'Optimizes .png/.jpg images using optipng/jpegtran', function() {\n    var cb = this.async(),\n      files = grunt.file.expandFiles(this.file.src);\n\n    var pngfiles = files.filter(function( file ) {\n      return png.indexOf( path.extname( file ).toLowerCase() ) !== -1;\n    });\n\n    var jpgfiles = files.filter(function( file ) {\n      return jpegs.indexOf( path.extname( file ).toLowerCase() ) !== -1;\n    });\n\n    grunt.helper('optipng', pngfiles, grunt.config('optipng'), function(err) {\n      if(err) {\n        grunt.log.error(err);\n        return cb(false);\n      }\n\n      grunt.helper('jpegtran', jpgfiles, grunt.config('jpegtran'), function(err) {\n        if(err) {\n          grunt.log.error(err);\n          return cb(false);\n        }\n        cb();\n      });\n    });\n  });\n\n  grunt.registerHelper('optipng', function(files, opts, cb) {\n    opts = opts || {};\n    cb = cb || function() {};\n\n    which('optipng', function(err, cmdpath) {\n      if ( err ) {\n        return grunt.helper( 'not installed', 'optipng', cb );\n      }\n\n      var args = opts.args ? opts.args : [];\n      args = args.concat(files);\n\n      if ( !files.length ) {\n        return cb();\n      }\n\n      grunt.log.writeln('Running optipng... ' + grunt.log.wordlist(files));\n      var optipng = grunt.util.spawn({\n        cmd: cmdpath,\n        args: args\n      }, function() {});\n\n      optipng.stdout.pipe(process.stdout);\n      optipng.stderr.pipe(process.stderr);\n      optipng.on('exit', function(code) {\n        if ( code ) {\n          grunt.warn( 'optipng exited unexpectedly with exit code ' + code + '.', code );\n        }\n        cb();\n      });\n    });\n  });\n\n  grunt.registerHelper('jpegtran', function(files, opts, cb) {\n    opts = opts || {};\n    cb = cb || function() {};\n    opts.args = opts.args ? opts.args : ['-copy', 'none', '-optimize', '-outfile', 'jpgtmp.jpg'];\n\n    which('jpegtran', function(err, cmdpath) {\n      if ( err ) {\n        return grunt.helper( 'not installed', 'jpegtran', cb );\n      }\n\n      (function run(file) {\n        if ( !file ) {\n          return cb();\n        }\n\n        grunt.log.subhead('** Processing: ' + file);\n        var jpegtran = grunt.util.spawn({\n          cmd: cmdpath,\n          args: opts.args.concat(file)\n        }, function() {});\n\n        jpegtran.stdout.pipe(process.stdout);\n        jpegtran.stderr.pipe(process.stderr);\n\n        jpegtran.on('exit', function(code) {\n          if ( code ) {\n            return grunt.warn( 'jpgtran exited unexpectedly with exit code ' + code + '.', code );\n          }\n          // output some size info about the file\n          grunt.helper('min_max_stat', 'jpgtmp.jpg', file);\n          // copy the temporary optimized jpg to original file\n          fs.createReadStream('jpgtmp.jpg')\n            .pipe(fs.createWriteStream(file)).on('close', function() {\n              run(files.shift());\n            });\n        });\n      }(files.shift()));\n    });\n\n  });\n\n  grunt.registerHelper('not installed', function(cmd, cb) {\n    grunt.verbose.or.writeln();\n    grunt.log.write('Running ' + cmd + '...').error();\n    grunt.log.errorlns([\n      'In order for this task to work properly, :cmd must be',\n      'installed and in the system PATH (if you can run \":cmd\" at',\n      'the command line, this task should work)'\n    ].join(' ').replace(/:cmd/g, cmd));\n    grunt.log.subhead('Skiping ' + cmd + ' task');\n\n    if ( cb ) {\n      cb();\n    }\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/manifest.js":"var url     = require('url');\nvar path    = require('path');\nvar join    = path.join;\nvar fstream = require('fstream');\n\nmodule.exports = function(grunt) {\n\n  // Launch a built-in webserver on the specified directory and run confess through phantomjs.\n  //\n  // This task can be used to run other confess task like performance or css,\n  // and can be configured to operate on a specific subdirectory.\n  //\n  // - task   - first task argument is used to specify the confess task to run\n  //            (default: appcache)\n  // - basdir - base directory of the app to cache (default: './')\n  //\n  // Examples\n  //\n  //    grunt manifest\n  //    grunt manifest:appcache:path/to/my/app\n  //    grunt manifest:performance:app\n  //    grunt manifest:performance:temp\n  //\n  // Advanced options can be configured below for expected options. Can be configures in the application gruntfile.\n  //\n  // Examples\n  //\n  //    manifest: {\n  //      task: 'appcache',\n  //      output: 'manifest.appcache',\n  //      port: 3501,\n  //      hostname: 'localhost',\n  //      base: 'app/'\n  //    }\n  //\n  //\n  grunt.registerTask('manifest', 'Generates an application cache manifest using Confess.js.', function() {\n    // port of the url to cache\n    var port = grunt.config('server.port') || 3501;\n\n    // default options\n    var options = grunt.util._.defaults(grunt.config(this.name) || {}, {\n      // confess task, set via first grunt task arg (default: appcache)\n      // performance, appcache, cssproperties\n      task: this.args[0] || 'appcache',\n      // output file\n      output: 'manifest.appcache',\n      // port of the url to cache,\n      port: port,\n      // hostname of the url to cache\n      hostname: 'localhost',\n      // basedir\n      base: path.resolve(this.args[1] || './'),\n      // if the browser should be \"opened\" to the app to cache\n      open: false,\n      // if the reload snippet from livereload should be injected or not\n      inject: false\n    });\n\n    // Tell grunt this task is asynchronous.\n    var done = this.async();\n\n    // start a webserver at the specified location\n    grunt.helper('server', options, function(err, port) {\n      if(err) {\n        return done( err );\n      }\n\n      options.port = port;\n      grunt.helper('manifest', options, done);\n    });\n\n  });\n\n  grunt.registerHelper('manifest', function(options, done) {\n    // base directory for confess files\n    var support  = join(__dirname, '../lib/support/');\n\n    // default options\n    grunt.util._.defaults(options, {\n      url: url.format({\n        protocol: 'http',\n        hostname: options.hostname || 'localhost',\n        port: options.port || 0\n      }),\n      task: 'appcache'\n    });\n\n    // slightly changed output file if task is not the usual appcache.\n    if(options.task !== 'appcache') {\n      options.output = options.output.replace(path.extname(options.output), '.' + options.task);\n    }\n\n    // and what command is about to run\n    var args = [\n      join(support, 'confess.js'),\n      options.url,\n      options.task,\n      // should be read from gruntfile, and write to temporary file\n      join(support, 'confess.json')\n    ];\n\n    grunt.log\n      .subhead('Generating the cache manifest')\n      .writeln('  - Command: ' + grunt.log.wordlist(['phantomjs'].concat(args), {\n        separator: ' '\n      }))\n      .subhead('Writing to ' + options.output + '...');\n\n    var confess = grunt.util.spawn({\n      cmd: 'phantomjs',\n      args: args\n    }, function(err) {\n      if( err ) {\n        grunt.fail.fatal(err);\n      }\n    });\n\n    // redirect back stderr output\n    confess.stderr.pipe( process.stderr );\n\n    // same for stdout, plus file write to final manifest file\n    confess.stdout.pipe( process.stdout );\n\n    confess.stdout.pipe( fstream.Writer(options.output) ).on('close', function() {\n      grunt.log.ok();\n      done();\n    });\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/misc.js":"\nvar fs = require('fs'),\n  path = require('path'),\n  utils = require('../').utils,\n  Ignore = require('fstream-ignore'),\n  fstream = require('fstream');\n\nmodule.exports = function(grunt) {\n\n  grunt.registerTask('intro', 'Kindly inform the developer about the impending magic', function() {\n    var intro = grunt.config('intro') || '';\n    intro = Array.isArray(intro) ? intro : [intro];\n    grunt.log.writeln(intro.join(utils.linefeed));\n  });\n\n  grunt.registerMultiTask('mkdirs', 'Prepares the build dirs', function() {\n    this.requires('clean');\n    this.requiresConfig('staging');\n\n    // store the current working directory, a subset of tasks needs to update\n    // the grunt.file.setBase accordinly on temp/ dir. And we might want\n    // chdir back to the original one\n    var base = grunt.config('base') || grunt.option('base') || process.cwd();\n    grunt.config('base', base);\n\n    var name = this.target,\n      target = path.resolve(grunt.config(name)),\n      source = path.resolve(this.data),\n      cb = this.async();\n\n    // todo a way to configure this from Gruntfile\n    var ignores = ['.gitignore', '.ignore', '.buildignore'];\n\n    grunt.log\n      .writeln('Copying into ' + target)\n      .writeln('Ignoring ' + grunt.log.wordlist(ignores));\n\n\n    grunt.helper('copy', source, target, ignores, function(e) {\n      if ( e ) {\n        grunt.log.error( e.stack || e.message );\n      } else {\n        grunt.log.ok( source + ' -> ' + target );\n      }\n\n      // Once copy done, ensure the current working directory is the temp one.\n      grunt.file.setBase(grunt.config('staging'));\n      cb(!e);\n    });\n  });\n\n  grunt.registerTask('copy', 'Copies the whole staging(temp/) folder to output (dist/) one', function() {\n    this.requiresConfig('staging', 'output');\n\n    var config = grunt.config(),\n      cb = this.async();\n\n    // prior to run the last copy step, switch back the cwd to the original one\n    // todo: far from ideal, would most likely go into other problem here\n    grunt.file.setBase(config.base);\n\n    // todo a way to configure this from Gruntfile\n    var ignores = ['.gitignore', '.ignore', '.buildignore'];\n\n    grunt.task.helper('copy', config.staging, config.output, ignores, function(e) {\n      if ( e ) {\n        grunt.log.error( e.stack || e.message );\n      } else {\n        grunt.log.ok( path.resolve( config.staging ) + ' -> ' + path.resolve( config.output ) );\n      }\n      cb(!e);\n    });\n  });\n\n  grunt.registerTask('clean', 'Wipe the previous build dirs', function() {\n    var dirs = [grunt.config('staging'), grunt.config('output')];\n    dirs.forEach(grunt.task._helpers.rimraf);\n  });\n\n  //\n  // **rimraf** is the helper wrapper for\n  // [rimraf](https://github.com/isaacs/rimraf#readme) package. The\n  // given `cb` callback if passed in will make the call asynchronous,\n  // otherwise `rimraf.sync` is used.\n  //\n  grunt.registerHelper('rimraf', function(dir, cb) {\n    if ( typeof cb !== 'function' ) {\n      return utils.rimraf.sync( dir );\n    }\n    utils.rimraf(dir, cb);\n  });\n\n  //\n  // **mkdir** helper is basic wrapper around\n  // [node-mkdirp](https://github.com/substack/node-mkdirp#readme).\n  // Takes a `directory` path to create, process is async if a valid\n  // callback function is passed in.\n  //\n  grunt.registerHelper('mkdir', function(dir, cb) {\n    if ( typeof cb !== 'function' ) {\n      return utils.mkdirp.sync( dir );\n    }\n    utils.mkdirp(dir, cb);\n  });\n\n\n  //\n  // **copy** helper uses [fstream-ignore](https://github.com/isaacs/fstream-ignore)\n  // to copy the files under the `src` (usually current directory) to the specified\n  // `dest`, optionnaly ignoring files specified by the `ignores` list of files.\n  //\n  // It filters out files that match globs in .ignore files throughout the tree,\n  // like how git ignores files based on a .gitignore file.\n  //\n  // This helper is asynchronous only. The whole stream \"pipeline\" of fstream-\n  // ignore is returned so that events mighh be listen to and furter streaming\n  // can be done, the result would be the final stream destination instance.\n  //\n  // The task will \"stream\" the result of fstream.Ignore to `dest`, which might\n  // be a raw writable Stream, or a String in which case a new fstream.Writer is\n  // created automatically. If the `dest` string ends with `.tar`, then the copy\n  // is done by creating a new/single `.tar` file.\n  //\n  // - source     - Path to the source directory.\n  // - dest       - where the files will be copied to. Can be a String or a\n  //                writable Stream. A new fstream.Writer (type directory) is\n  //                created is dest is a String.\n  // - ignores    - (optional) An Array of ignores files\n  // - cb         - callback to call on completion\n  //\n  //\n  grunt.registerHelper('copy', function(src, dest, ignores, cb) {\n    if(!cb) { cb = ignores; ignores = ['.gitignore', '.ignore', '.buildignore']; }\n\n    function error(msg) {\n      return function(e) {\n          if(!e) {\n            grunt.log.writeln();\n            return cb();\n          }\n\n          grunt.log.error('Oh snap >> ' + msg);\n          grunt.log.error(e);\n          return cb(false);\n      };\n    }\n\n    var type = typeof dest !== 'string' ? 'stream' :\n      path.extname(dest) === '.tar' ? 'tar' :\n      path.extname(dest) === '.tgz' ? 'tgz' :\n      'dir';\n\n    var stream = new Ignore({ path: src, ignoreFiles: ignores })\n      .on('child', function (c) {\n        var p = c.path.substr(c.root.path.length + 1);\n        grunt.log.verbose.writeln('>>' + p.grey);\n        grunt.log.verbose.or.write('.');\n      })\n      .on('error', error('fstream-ignore reading error'));\n\n    // raw stream pipe it through\n    if ( type === 'stream' )  {\n      return stream.pipe( dest )\n        .on( 'error', error('pipe error with raw stream') )\n        .on( 'close', error() );\n    }\n\n    // tar type, create a new \"packer\": tar.Pack(), zlib.Gzip(), fs.WriteStream\n    if ( /tar|tgz/.test( type ) ) {\n      return grunt.helper( 'packer', stream, dest, error );\n    }\n\n    // dir type, create a new fstream.Writer and let fstream do all the complicated stuff for us\n    if ( type === 'dir' ) {\n      return stream.pipe( fstream.Writer({\n        path: dest,\n        type: 'Directory'\n      }))\n        .on( 'error', error('pipe error with dir stream') )\n        .on( 'close', error() );\n    }\n  });\n\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/rev.js":"\n\nvar fs = require('fs'),\n  path = require('path'),\n  crypto = require('crypto');\n\n\nmodule.exports = function(grunt) {\n  // rev task - reving is done in the `output/` directory\n  grunt.registerMultiTask('rev', 'Automate the hash renames of assets filename', function() {\n    grunt.helper('hash', this.data);\n  });\n\n  // **hash** helper takes care of files revving, by renaming any files\n  // in the given `files` pattern(s), with passed in `options`.\n  //\n  // - files      - String or Array of glob pattern\n  // - options    - (optional) An Hash object where:\n  //    - cwd     - Base directory to work from, glob patterns are\n  //                prepended to this path.\n  //\n  grunt.registerHelper('hash', function(files, opts) {\n    opts = opts || {};\n\n    grunt.file.expandFiles(files).forEach(function(f) {\n      var md5 = grunt.helper('md5', f),\n        renamed = [md5.slice(0, 8), path.basename(f)].join('.');\n\n      grunt.verbose.ok().ok(md5);\n      // create the new file\n      fs.renameSync(f, path.resolve(path.dirname(f), renamed));\n      grunt.log.write(f + ' ').ok(renamed);\n    });\n  });\n\n\n  // **md5** helper is a basic wrapper around crypto.createHash, with\n  // given `algorithm` and `encoding`. Both are optional and defaults to\n  // `md5` and `hex` values.\n  grunt.registerHelper('md5', function(filepath, algorithm, encoding) {\n    algorithm = algorithm || 'md5';\n    encoding = encoding || 'hex';\n    var hash = crypto.createHash(algorithm);\n    hash.update(grunt.file.read(filepath));\n    grunt.log.verbose.write('Hashing ' + filepath + '...');\n    return hash.digest(encoding);\n  });\n};\n\n\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/rjs.js":"var fs = require('fs'),\n  path = require('path'),\n  rjs = require('requirejs'),\n  vm = require('vm');\n\nmodule.exports = function(grunt) {\n  grunt.task.registerTask('rjs', 'Optimizes javascript that actually is built with requirejs.', function () {\n    var options = grunt.config(this.name) || {};\n\n    // Verify if the application contains a data-main attribute\n    var appIndexPath  = path.resolve('mainFile' in options ? '../app/' + options.mainFile : '../app/index.html');\n    var indexBuffer = fs.readFileSync(appIndexPath, 'utf8');\n    var hasDataMain = (indexBuffer.match(/data-main=['\"]([^'\"]+)['\"]/));\n\n    if(hasDataMain === null){\n      grunt.log.writeln('No data-main attribute found in application index, bypassing the task...');\n      return;\n    }\n\n    // Check for module/entry points in the rjs config\n    if(!options.modules && !options.name) {\n      grunt.log.writeln('No module or single entry point found in rjs configuration, bypassing the task...');\n      return;\n    }\n\n    grunt.helper('rjs:optimize:js', grunt.config(this.name), this.async());\n  });\n\n  grunt.registerHelper('rjs:optimize:js', function(options, cb) {\n    if(!cb) { cb = options; options = {}; }\n    var mods = options.modules || [{ name: options.name }];\n\n    // automatic configuration via mainConfigFile, assumed to be the app entry\n    // point\n    if(options.name) {\n      options.mainConfigFile = options.mainConfigFile || path.join(options.baseUrl, options.name + '.js');\n    }\n\n    grunt.log.subhead('Options:')\n      .writeln(grunt.helper('inspect', options));\n\n    var originals = mods.map(function(m) {\n      return {\n        name: m.name,\n        body: grunt.file.read(path.join(options.appDir, options.baseUrl, m.name + '.js'))\n      };\n    });\n\n    rjs.optimize(options, function(out) {\n      grunt.log.writeln(out);\n      originals.forEach(function(m) {\n        var filepath = path.join(options.dir, options.baseUrl, m.name + '.js');\n        grunt.log\n          .writeln('rjs optimized module: ' + m.name)\n          .writeln('>> ' + filepath);\n\n        grunt.helper('min_max_info', grunt.file.read(filepath), m.body);\n      });\n\n      cb();\n    });\n  });\n\n};","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/server.js":"\nvar fs = require('fs'),\n  path = require('path'),\n  util = require('util'),\n  http = require('http'),\n  events = require('events'),\n  colors = require('colors'),\n  connect = require('connect'),\n  WebSocket = require('faye-websocket'),\n  open = require('open'),\n  WeakMap = require('es6-collections').WeakMap;\n\nmodule.exports = function(grunt) {\n  var priv = new WeakMap();\n\n  // Reactor object\n  // ==============\n\n  // Somewhat a port of guard-livereload's Reactor class\n  // https://github.com/guard/guard-livereload/blob/master/lib/guard/livereload/reactor.rb\n  //\n  // XXX may very well go into our lib/ directory (which needs a good cleanup)\n\n  function Reactor(options) {\n    this.sockets = {};\n\n    if ( !options.server ) {\n      throw new Error('Missing server option');\n    }\n\n    this.server = options.server;\n\n    if ( !( this.server instanceof http.Server ) ) {\n      throw new Error('Is not a valid HTTP server');\n    }\n\n    this.options = options || {};\n    this.uid = 0;\n\n    this.start(options);\n  }\n\n  util.inherits(Reactor, events.EventEmitter);\n\n  // send a reload command on all stored web socket connection\n  Reactor.prototype.reload = function reload(files) {\n    var sockets = this.sockets,\n      changed = files.changed;\n\n    // go through all sockets, and emit a reload command\n    Object.keys(sockets).forEach(function(id) {\n      var ws = sockets[id],\n        version = ws.livereloadVersion;\n\n      // go throuh all the files that has been marked as changed by grunt\n      // and trigger a reload command on each one, for each connection.\n      changed.forEach(this.reloadFile.bind(this, version));\n    }, this);\n  };\n\n  Reactor.prototype.reloadFile = function reloadFile(version, filepath) {\n    // > as full as possible/known, absolute path preferred, file name only is\n    // > OK\n    filepath = path.resolve(filepath);\n\n    // support both \"refresh\" command for 1.6 and 1.7 protocol version\n    var data = version === '1.6' ? ['refresh', {\n      path: filepath,\n      apply_js_live: true,\n      apply_css_live: true\n    }] : {\n      command: 'reload',\n      path: filepath,\n      liveCSS: true,\n      liveJS: true\n    };\n\n    this.send(data);\n  };\n\n  Reactor.prototype.start = function start() {\n    // setup socket connection\n    this.server.on('upgrade', this.connection.bind(this));\n  };\n\n  Reactor.prototype.connection = function connection(request, socket, head) {\n    var ws = new WebSocket(request, socket, head),\n      wsId = this.uid = this.uid + 1;\n\n    // store the new connection\n    this.sockets[wsId] = ws;\n\n    ws.onmessage = function(event) {\n      // message type\n      if ( event.type !== 'message' ) {\n        return console.warn('Unhandled ws message type');\n      }\n\n      // parse the JSON data object\n      var data = this.parseData(event.data);\n\n      // attach the guessed livereload protocol version to the sokect object\n      ws.livereloadVersion = data.command ? '1.7' : '1.6';\n\n      // data sent wasn't a valid JSON object, assume version 1.6\n      if ( !data.command ) {\n        return ws.send('!!ver:1.6');\n      }\n\n      // valid commands are: url, reload, alert and hello for 1.7\n\n      // first handshake\n      if ( data.command === 'hello' ) {\n        return this.hello( data );\n      }\n\n      // livereload.js emits this\n      if ( data.command === 'info' ) {\n        return this.info( data );\n      }\n    }.bind(this);\n\n    ws.onclose = function() {\n      ws = null;\n      delete this.sockets[wsId];\n\n      priv.set(this, {\n        ws: null\n      });\n    }.bind(this);\n\n    priv.set(this, {\n      ws: ws\n    });\n  };\n\n  Reactor.prototype.parseData = function parseData(str) {\n    var data = {};\n    try {\n      data = JSON.parse(str);\n    } catch (e) {}\n    return data;\n  };\n\n  Reactor.prototype.hello = function hello() {\n    this.send({\n      command: 'hello',\n      protocols: [\n        'http://livereload.com/protocols/official-7'\n      ],\n      serverName: 'yeoman-livereload'\n    });\n\n  };\n\n  // noop\n  Reactor.prototype.info = function info() {};\n\n  Reactor.prototype.send = function send(data) {\n    var ws = priv.get(this).ws;\n\n    ws.send(JSON.stringify(data));\n  };\n\n\n  // Tasks & Helpers\n  // ===============\n\n  // Retain grunt's built-in server task.\n  grunt.renameTask('server', 'grunt-server');\n\n  // The server task always run with the watch task, this is done by\n  // aliasing the server task to the relevant set of task to run.\n  grunt.registerTask('server', 'yeoman-server watch');\n\n  // Reload handlers\n  // ---------------\n\n  // triggered by a watch handler to emit a reload event on all livereload\n  // established connection\n  grunt.registerTask('reload', '(internal) livereload interface', function() {\n    // get the reactor instance\n    var reactor = grunt.helper('reload:reactor');\n\n    // and send a reload command to all browsers\n    reactor.reload(grunt.file.watchFiles);\n  });\n\n  // Factory for the reactor object\n  var reactor;\n  grunt.registerHelper('reload:reactor', function(options) {\n    if ( options && !reactor ) {\n      reactor = new Reactor( options );\n    }\n    return reactor;\n  });\n\n\n  // Server\n  // ------\n\n  // Note: yeoman-server alone will exit prematurly unless `this.async()` is\n  // called. The task is designed to work alongside the `watch` task.\n  grunt.registerTask('server', 'Launch a preview, LiveReload compatible server', function(target) {\n    var opts;\n    // Get values from config, or use defaults.\n    var port = grunt.config('server.port') || 0xDAD;\n\n    // async task, call it (or not if you wish to use this task standalone)\n    var cb = this.async();\n\n    // valid target are app (default), prod and test\n    var targets = {\n      // these paths once config and paths resolved will need to pull in the\n      // correct paths from config\n      app: path.resolve('app'),\n      dist: path.resolve('dist'),\n      test: path.resolve('test'),\n\n      // phantom target is a special one: it is triggered\n      // before launching the headless tests, and gives\n      // to phantomjs visibility on the same paths a\n      // server:test have.\n      phantom: path.resolve('test'),\n\n      // reload is a special one, acting like `app` but not opening the HTTP\n      // server in default browser and forcing the port to LiveReload standard\n      // port.\n      reload: path.resolve('app')\n    };\n\n    target = target || 'app';\n\n    // yell on invalid target argument\n    if(!targets[target]) {\n      grunt\n        .log.error('Not a valid target: ' + target)\n        .writeln('Valid ones are: ' + grunt.log.wordlist(Object.keys(targets)));\n      return false;\n    }\n\n    var tasks = {\n      // We do want our coffee, and compass recompiled on change\n      // and our browser opened and refreshed both when developping\n      // (app) and when writing tests (test)\n      app: 'clean coffee compass open-browser watch',\n      test: 'clean coffee compass open-browser watch',\n      // Before our headless tests are run, ensure our coffee\n      // and compass are recompiled\n      phantom: 'clean coffee compass',\n      dist: 'watch',\n      reload: 'watch'\n    };\n\n    opts = {\n      // prevent browser opening on `reload` target\n      open: target !== 'reload',\n      // and force 35729 port no matter what when on `reload` target\n      port: target === 'reload' ? 35729 : port,\n      base: targets[target],\n      inject: true,\n      target: target,\n      hostname: grunt.config('server.hostname') || 'localhost'\n    };\n\n    grunt.helper('server', opts, cb);\n\n    grunt.registerTask('open-browser', function() {\n        if ( opts.open ) {\n          open( 'http://' + opts.hostname + ':' + opts.port );\n        }\n    });\n\n    grunt.task.run( tasks[target] );\n  });\n\n  grunt.registerHelper('server', function(opts, cb) {\n    cb = cb || function() {};\n\n    var middleware = [];\n\n    // add the special livereload snippet injection middleware\n    if ( opts.inject ) {\n      middleware.push( grunt.helper('reload:inject', opts) );\n    }\n\n    // also serve static files from the temp directory, and before the app\n    // one (compiled assets takes precedence over same pathname within app/)\n    middleware.push(connect.static(path.join(opts.base, '../temp')));\n    // Serve static files.\n    middleware.push(connect.static(opts.base));\n   // Make empty directories browsable.\n    middleware.push(connect.directory(opts.base));\n\n    if ( (opts.target === 'test') || ( opts.target === 'phantom')) {\n      // We need to expose our code as well\n      middleware.push(connect.static(path.resolve('app')));\n      // Make empty directories browsable.\n      middleware.push(connect.directory(path.resolve('app')));\n    }\n\n    middleware = middleware.concat([\n      // Serve the livereload.js script\n      connect.static(path.join(__dirname, 'livereload')),\n      // To deal with errors, 404 and alike.\n      grunt.helper('server:errorHandler', opts),\n      // Connect error handler (for better looking error pages)\n      connect.errorHandler()\n    ]);\n\n    // the connect logger format if --debug was specified. Get values from\n    // config or use defaults.\n    var format = grunt.config('server.logformat') || (\n      '[D] server :method :url :status ' +\n      ':res[content-length] - :response-time ms'\n    );\n\n    // If --debug was specified, enable logging.\n    if (grunt.option('debug')) {\n      connect.logger.format('yeoman', format.magenta);\n      middleware.unshift(connect.logger('yeoman'));\n    }\n\n    return connect.apply(null, middleware)\n      .on('error', function( err ) {\n        if ( err.code === 'EADDRINUSE' ) {\n          return this.listen(0); // 0 means random port\n        }\n\n        // not an EADDRINUSE error, buble up the error\n        cb(err);\n      })\n      .listen(opts.port, function() {\n        var port = this.address().port;\n\n        // Start server.\n        grunt.log\n          .subhead( 'Starting static web server on port '.yellow + String( port ).red )\n          .writeln( '  - ' + path.resolve(opts.base) )\n          .writeln('I\\'ll also watch your files for changes, recompile if neccessary and live reload the page.')\n          .writeln('Hit Ctrl+C to quit.');\n\n        // create the reactor object\n        grunt.helper('reload:reactor', {\n          server: this,\n          apiVersion: '1.7',\n          host: opts.hostname,\n          port: port\n        });\n\n        cb(null, port);\n      });\n  });\n\n\n  // Error handlers\n  // --------------\n\n  // Grunt helper providing a connect middleware focused on dealing with\n  // errors. Assuming this middleware is at the bottom of your stack, deals\n  // with incoming request as 404 errors. It then tries to add a more\n  // meaningful message, based on provided `options`.\n  //\n  // - opts       - Hash of options where\n  //    - base    - is the base directory and helps to determine a more\n  //                specific message\n  //    - target  - The base target name (app, dist, test) to act upon\n  //\n  //\n  // If a grunt helper with a `server:error:<target>` name is registered,\n  // invoke it, passing in the original error and associated pathname.\n  //\n  // It changes the exports.title property used internally by\n  // connect.errorHandler (to update the Page title to be Yeoman instead of\n  // Connect).\n  //\n  // In a next step, we might want to craft our own custom errorHandler, based\n  // on http://www.senchalabs.org/connect/errorHandler.html to customize a bit\n  // more.\n  grunt.registerHelper('server:errorHandler', function(opts) {\n    opts = opts || {};\n    opts.target = opts.target || 'app';\n    connect.errorHandler.title = 'Yeoman';\n    return function errorHandler(req, res, next) {\n      // Figure out the requested path\n      var pathname = req.url;\n      // asume 404 all the way.\n      var err = connect.utils.error(404);\n      err.message = pathname + ' ' + err.message;\n\n      // Using events would be better here, but the `res.socket.server`\n      // instance doesn't seem to be same than the one returned by connect()\n      if(grunt.task._helpers['server:error:' + opts.target]) {\n        grunt.helper('server:error:' + opts.target, err, pathname);\n      }\n\n      // go next, and pass in the crafted error object\n      next(err);\n    };\n  });\n\n  // Target specific error handlers. Alter the error object as you see fit.\n  grunt.registerHelper('server:error:dist', function(err, pathname) {\n    // handle specific pathname here, `/` on dist target as special meaning.\n    // Most likely missing a build run.\n    if(pathname === '/') {\n      err.message = 'Missing /dist folder.';\n      // connect middleware slice at position 1, append an Empty String (usually Error: err.message)\n      err.stack = [\n        '',\n        'You need to run yeoman build first.',\n        '',\n        '<code>yeoman build</code>'\n      ].join('\\n');\n    }\n  });\n\n\n  // LiveReload\n  // ----------\n  //\n  // XXX Reactor and this inject middleware should be put in `livereload/*.js`.\n  // At some point, it might be reanmed from `livereload/` to `server/`, and\n  // put any non specific grunt piece of code (like the few connect middleware\n  // in there) in this folder, with multiple files. Then, the grunt.helper is\n  // registered using `grunt.registerHelper('reload:inject', require('./server/inject'))`\n\n\n  // Grunt helper returning a valid connect / express middleware.  Its job is\n  // to setup a middleware right before the usual static one, and to bypass the\n  // response of `.html` file to render them with additional scripts.\n  grunt.registerHelper('reload:inject', function(opts) {\n    opts = opts || {};\n\n    return function inject(req, res, next) {\n\n      // build filepath from req.url and deal with index files for trailing `/`\n      var filepath = req.url.slice(-1) === '/' ? req.url + 'index.html' : req.url;\n\n      // if ext is anything but .html, let it go through usual connect static\n      // middleware.\n      if ( path.extname( filepath ) !== '.html' ) {\n        return next();\n      }\n\n      var port = res.socket.server.address().port;\n\n      // setup some basic headers, at this point it's always text/html anyway\n      res.setHeader('Content-Type', connect.static.mime.lookup(filepath));\n\n      // can't use the ideal stream / pipe case, we need to alter the html response\n      // by injecting that little livereload snippet\n      filepath = path.join(opts.base, filepath.replace(/^\\//, ''));\n      fs.readFile(filepath, 'utf8', function(e, body) {\n        if(e) {\n          // go next and silently fail\n          return next();\n        }\n\n        body = body.replace(/<\\/body>/, function(w) {\n          return [\n            \"<!-- yeoman livereload snippet -->\",\n            \"<script>document.write('<script src=\\\"http://'\",\n            \" + (location.host || 'localhost').split(':')[0]\",\n            \" + ':\" + port + \"/livereload.js?snipver=1\\\"><\\\\/script>')\",\n            \"</script>\",\n            \"\",\n            w\n          ].join('\\n');\n        });\n\n        res.end(body);\n      });\n    };\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/tar.js":"\nvar path = require('path'),\n  fstream = require('fstream'),\n  zlib = require('zlib'),\n  tar = require('tar');\n\nmodule.exports = function(grunt) {\n\n  //\n  // **tar** task is a basic task for tarball creation. Takes two options: the\n  // directory (`input`) to read from and the tarball file to create\n  // (`output`). Depending on tarball extension (either .tar or .tgz), tarball\n  // file is also passed through zlib.Gzip().\n  //\n  // The tar task will try to get the input / output options from different\n  // sources, in this order:\n  //\n  // - cli options for `--input` and `--output`\n  // - configuration for tar.input and tar.output (usually in project's Gruntfile)\n  //\n  // If one of `--input` or `--output` is not defined, then the task looks for\n  // these values in grunt's config, and fail if either input or output is\n  // missing.\n  //\n  grunt.registerTask('tar', 'Creates a tarball from a directory', function() {\n    var input = grunt.option('input') || grunt.config('input'),\n      output = grunt.option('output') || grunt.config('output'),\n      cb = this.async();\n\n    if ( !input ) {\n      grunt.log.error('tar: No input value, please specify one.');\n    }\n\n    if ( !output ) {\n      grunt.log.error('tar: No output value, please specify one.');\n    }\n\n    if ( !input || !output ) {\n      return cb(false);\n    }\n\n    // correct extension?\n    if(!(/tar|tgz/).test(path.extname(output))) {\n      grunt.log.error('tar: ' + output + ' is not a valid destination. Must ends with .tar or .tgz');\n      return cb(false);\n    }\n\n    grunt.log.write('Creating tarball >> ' + output + ' from ' + input + ' directory...');\n\n    //\n    // Note to self: should the tar task use fstream-ignore instead? By default\n    // and for now, assuming the tar task is used to copy the whole folder,\n    // without ignore handling. But seems like the correct way to do so, as the\n    // stuff ignores by .gitignore or other ignore files are likely not\n    // intended to be copied.\n    //\n    var reader = fstream.Reader({ type: 'Directory', path: input });\n    grunt.helper('packer', reader, output, function(msg) {\n      return function(e) {\n        // no errors.. All ok.\n        if(!e) {\n          grunt.log.ok();\n          return cb();\n        }\n        // hmm, got error, log and fail\n        grunt.log.error('Oh snap >> ' + msg);\n        grunt.log.error(e);\n        return cb(false);\n      };\n    });\n  });\n\n  //\n  // **packer** is a simple pass-through stream helper using zlib and\n  // isaacs/node-tar.  Takes a readable fstream (like a fstream.Reader or\n  // fstream-ignore), pass it through tar.Pack() with default option, then into\n  // zlib.Gzip() and finally to a writable fs Stream.\n  //\n  // gzipping is optional and only happens when dest ends with `.tgz`. Dest\n  // ending with `.tar` will omit the zlib.Gzip() step.\n  //\n  // Error is a curried function.. Not a raw callback, it returns the callback\n  // to call on completion though, done this way mainly to circumvent the fact that\n  // grunt's async callback currently handles instanceof Errors as truthy\n  // value, hence not failing the task.\n  //\n  // note to self: now that packer helper is used by more than one task, should\n  // simplify this error callback stuff (and not rely on curried thing,\n  // confusing for little value)\n  //\n  grunt.registerHelper('packer', function(input, dest, error) {\n    var stream = input.pipe(tar.Pack())\n      .on('error', error('tar creation error' + dest));\n\n    // if it ends with .tgz, then Gzip it.\n    if ( path.extname( dest ) === '.tgz' ) {\n      stream = stream.pipe( zlib.Gzip() );\n    }\n\n    return stream.on('error', error('gzip error ' + dest))\n      .pipe(fstream.Writer({ type: 'File', path: dest }))\n      .on('error', error('Could not write ' + dest))\n      .on('close', error());\n  });\n};\n\n\n\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/usemin.js":"\nvar fs = require('fs'),\n  path = require('path');\n\n//\n// ### Usemin\n\n// Replaces references to non-optimized scripts or stylesheets\n// into a set of HTML files (or any templates/views).\n//\n// The users markup should be considered the primary source of information\n// for paths, references to assets which should be optimized.We also check\n// against files present in the relevant directory () (e.g checking against\n// the revved filename into the 'temp/') directory to find the SHA\n// that was generated.\n//\n// Todos:\n// * Use a file dictionary during build process and rev task to\n// store each optimized assets and their associated sha1.\n// * Update usemin-handler to follow @necolas proposed structure\n//\n// Thx to @krzychukula for the new, super handy replace helper.\n//\n// #### Usemin-handler\n//\n// A special task which uses the build block HTML comments in markup to\n// get back the list of files to handle, and initialize the grunt configuration\n// appropriately, and automatically.\n//\n// Custom HTML \"block\" comments are provided as an API for interacting with the\n// build script. These comments adhere to the following pattern:\n//\n//     <!-- build:<type> <path> -->\n//       ... HTML Markup, list of script / link tags.\n//     <!-- endbuild -->\n//\n// - type: is either js or css.\n// - path: is the file path of the optimized file, the target output.\n//\n// An example of this in completed form can be seen below:\n//\n//    <!-- build:js js/app.js -->\n//      <script src=\"js/app.js\"></script>\n//      <script src=\"js/controllers/thing-controller.js\"></script>\n//      <script src=\"js/models/thing-model.js\"></script>\n//      <script src=\"js/views/thing-view.js\"></script>\n//    <!-- endbuild -->\n//\n//\n// Internally, the task parses your HTML markup to find each of these blocks, and\n// initializes for you the corresponding Grunt config for the concat / min tasks\n// when `type=js`, the concat / css tasks when `type=css`.\n//\n// The task also handles use of RequireJS, for the scenario where you specify\n// the main entry point for your application using the \"data-main\" attribute\n// as follows:\n//\n//     <!-- build:js js/app.min.js -->\n//     <script data-main=\"js/main\" src=\"js/vendor/require.js\"></script>\n//     <!-- -->\n//\n// One doesn't need to specify a concat/min/css or rjs configuration anymore.\n//\n// Inspired by previous work in https://gist.github.com/3024891\n// For related sample, see: cli/test/tasks/usemin-handler/index.html\n//\n\n\n//\n// Helpers: todo, register as grunt helper\n//\n\n// start build pattern --> <!-- build:[target] output -->\nvar regbuild = /<!--\\s*build:(\\w+)\\s*(.+)\\s*-->/;\n\n// end build pattern -- <!-- endbuild -->\nvar regend = /<!--\\s*endbuild\\s*-->/;\n\n\n//\n// Returns an hash object of all the directives for the given html. Results is\n// of the following form:\n//\n//     {\n//        'css/site.css ':[\n//          '  <!-- build:css css/site.css -->',\n//          '  <link rel=\"stylesheet\" href=\"css/style.css\">',\n//          '  <!-- endbuild -->'\n//        ],\n//        'js/head.js ': [\n//          '  <!-- build:js js/head.js -->',\n//          '  <script src=\"js/libs/modernizr-2.5.3.min.js\"></script>',\n//          '  <!-- endbuild -->'\n//        ],\n//        'js/site.js ': [\n//          '  <!-- build:js js/site.js -->',\n//          '  <script src=\"js/plugins.js\"></script>',\n//          '  <script src=\"js/script.js\"></script>',\n//          '  <!-- endbuild -->'\n//        ]\n//     }\n//\nfunction getBlocks(body) {\n  var lines = body.replace(/\\r\\n/g, '\\n').split(/\\n/),\n    block = false,\n    sections = {},\n    last;\n\n  lines.forEach(function(l) {\n    var build = l.match(regbuild),\n      endbuild = regend.test(l);\n\n    if(build) {\n      block = true;\n      sections[[build[1], build[2].trim()].join(':')] = last = [];\n    }\n\n    // switch back block flag when endbuild\n    if(block && endbuild) {\n      last.push(l);\n      block = false;\n    }\n\n    if(block && last) {\n      last.push(l);\n    }\n  });\n\n// Todo: Change to match @necolas suggested structure for the usemin blocks.\n// {\n//   type: 'css',\n//   dest: 'css/site.css',\n//   src: [\n//     'css/normalize.css',\n//     'css/main.css'\n//   ],\n//   raw: [\n//     '    <!-- build:css css/site.css -->',\n//     '    <link rel=\"stylesheet\" href=\"css/normalize.css\">',\n//     '    <link rel=\"stylesheet\" href=\"css/main.css\">',\n//     '    <!-- endbuild -->'\n//   ]\n// }\n\n  return sections;\n}\n\n\nmodule.exports = function(grunt) {\n\n  grunt.registerMultiTask('usemin', 'Replaces references to non-minified scripts / stylesheets', function() {\n\n    var name = this.target,\n      data = this.data,\n      files = grunt.file.expand(data);\n\n    files.map(grunt.file.read).forEach(function(content, i) {\n      var p = files[i];\n\n      grunt.log.subhead('usemin:' + name + ' - ' + p);\n\n      // make sure to convert back into utf8, `file.read` when used as a\n      // forEach handler will take additional arguments, and thus trigger the\n      // raw buffer read\n      content = content.toString();\n\n      // ext-specific directives handling and replacement of blocks\n      if(!!grunt.task._helpers['usemin:pre:' + name]) {\n        content = grunt.helper('usemin:pre:' + name, content);\n      }\n\n      // actual replacement of revved assets\n      if(!!grunt.task._helpers['usemin:post:' + name]) {\n        content = grunt.helper('usemin:post:' + name, content);\n      }\n\n      // write the new content to disk\n      grunt.file.write(p, content);\n    });\n\n  });\n\n  grunt.registerMultiTask('usemin-handler', 'Using HTML markup as the primary source of information', function() {\n    // collect files\n    var files = grunt.file.expandFiles(this.data);\n\n    // concat / min / css / rjs config\n    var concat = grunt.config('concat') || {},\n      min = grunt.config('min') || {},\n      css = grunt.config('css') || {},\n      rjs = grunt.config('rjs') || {};\n\n    grunt.log\n      .writeln('Going through ' + grunt.log.wordlist(files) + ' to update the config')\n      .writeln('looking for build script HTML comment blocks');\n\n    files = files.map(function(filepath) {\n      return {\n        path: filepath,\n        body: grunt.file.read(filepath)\n      };\n    });\n\n    files.forEach(function(file) {\n      var blocks = getBlocks(file.body);\n      Object.keys(blocks).forEach(function(dest) {\n        var lines = blocks[dest].slice(1, -1),\n          parts = dest.split(':'),\n          type = parts[0],\n          output = parts[1];\n        // Handle absolute path (i.e. with respect to th eserver root)\n        if (output[0] === '/') {\n          output = output.substr(1);\n        }\n\n        // parse out the list of assets to handle, and update the grunt config accordingly\n        var assets = lines.map(function(tag) {\n          var asset = (tag.match(/(href|src)=[\"']([^'\"]+)[\"']/) || [])[2];\n\n          // RequireJS uses a data-main attribute on the script tag to tell it\n          // to load up the main entry point of the amp app\n          //\n          // First time we findd one, we update the name / mainConfigFile\n          // values. If a name of mainConfigFile value are already set, we skip\n          // it, so only one match should happen and default config name in\n          // original Gruntfile is used if any.\n          var main = tag.match(/data-main=['\"]([^'\"]+)['\"]/);\n          if(main) {\n            rjs.out = rjs.out || output;\n            rjs.name = rjs.name || main[1];\n            asset += ',' + output;\n          }\n\n          return asset;\n        }).reduce(function(a, b) {\n          b = ( b ? b.split(',') : '');\n          return a.concat(b);\n        }, []);\n\n        grunt.log.subhead('Found a block:')\n          .writeln(grunt.log.wordlist(lines, { separator: '\\n' }))\n          .writeln('Updating config with the following assets:')\n          .writeln('    - ' + grunt.log.wordlist(assets, { separator: '\\n    - ' }));\n\n        // update concat config for this block\n        concat[output] = assets;\n        grunt.config('concat', concat);\n\n        // update rjs config as well, as during path lookup we might have\n        // updated it on data-main attribute\n        grunt.config('rjs', rjs);\n\n        // min config, only for js type block\n        if(type === 'js') {\n          min[output] = output;\n          grunt.config('min', min);\n        }\n\n        // css config, only for css type block\n        if(type === 'css') {\n          css[output] = output;\n          grunt.config('css', css);\n        }\n      });\n    });\n\n    // log a bit what was added to config\n    grunt.log.subhead('Configuration is now:')\n      .subhead('  css:')\n      .writeln('  ' + grunt.helper('inspect', css))\n      .subhead('  concat:')\n      .writeln('  ' + grunt.helper('inspect', concat))\n      .subhead('  min:')\n      .writeln('  ' + grunt.helper('inspect', min))\n      .subhead('  rjs:')\n      .writeln('  ' + grunt.helper('inspect', rjs));\n\n  });\n\n  // Helpers\n  // -------\n\n  // usemin:pre:* are used to preprocess files with the blocks and directives\n  // before going through the global replace\n  grunt.registerHelper('usemin:pre:html', function(content) {\n    // XXX extension-specific for get blocks too.\n    //\n    // Eg. for each predefined extensions directives may vary. eg <!--\n    // directive --> for html, /** directive **/ for css\n    var blocks = getBlocks(content);\n\n    // Determine the linefeed from the content\n    var linefeed = /\\r\\n/g.test(content) ? '\\r\\n' : '\\n';\n\n    // handle blocks\n    Object.keys(blocks).forEach(function(key) {\n      var block = blocks[key].join(linefeed),\n        parts = key.split(':'),\n        type = parts[0],\n        target = parts[1];\n\n      content = grunt.helper('usemin', content, block, target, type);\n    });\n\n    return content;\n  });\n\n  // usemin and usemin:* are used with the blocks parsed from directives\n  grunt.registerHelper('usemin', function(content, block, target, type) {\n    target = target || 'replace';\n    return grunt.helper('usemin:' + type, content, block, target);\n  });\n\n  grunt.registerHelper('usemin:css', function(content, block, target) {\n    var linefeed = /\\r\\n/g.test(content) ? '\\r\\n' : '\\n';\n    var indent = (block.split(linefeed)[0].match(/^\\s*/) || [])[0];\n    return content.replace(block, indent + '<link rel=\"stylesheet\" href=\"' + target + '\"\\/>');\n  });\n\n  grunt.registerHelper('usemin:js', function(content, block, target) {\n    var linefeed = /\\r\\n/g.test(content) ? '\\r\\n' : '\\n';\n    var indent = (block.split(linefeed)[0].match(/^\\s*/) || [])[0];\n    return content.replace(block, indent + '<script src=\"' + target + '\"></script>');\n  });\n\n  grunt.registerHelper('usemin:post:css', function(content) {\n    grunt.log.writeln('Update the CSS with new img filenames');\n    content = grunt.helper('replace', content, /url\\(\\s*['\"]([^\"']+)[\"']\\s*\\)/gm);\n    return content;\n  });\n\n  // usemin:post:* are the global replace handlers, they delegate the regexp\n  // replace to the replace helper.\n  grunt.registerHelper('usemin:post:html', function(content) {\n    grunt.log.verbose.writeln('Update the HTML to reference our concat/min/revved script files');\n    content = grunt.helper('replace', content, /<script.+src=['\"](.+)[\"'][\\/>]?><[\\\\]?\\/script>/gm);\n\n    grunt.log.verbose.writeln('Update the HTML with the new css filenames');\n    content = grunt.helper('replace', content, /<link[^\\>]+href=['\"]([^\"']+)[\"']/gm);\n\n    grunt.log.verbose.writeln('Update the HTML with the new img filenames');\n    content = grunt.helper('replace', content, /<img[^\\>]+src=['\"]([^\"']+)[\"']/gm);\n\n    grunt.log.verbose.writeln('Update the HTML with background imgs, case there is some inline style');\n    content = grunt.helper('replace', content, /url\\(\\s*['\"]([^\"']+)[\"']\\s*\\)/gm);\n\n    grunt.log.verbose.writeln('Update the HTML with anchors images');\n    content = grunt.helper('replace', content, /<a[^\\>]+href=['\"]([^\"']+)[\"']/gm);\n\n    return content;\n  });\n\n  grunt.registerHelper('usemin:post:css', function(content) {\n\n    grunt.log.verbose.writeln('Update the CSS with background imgs, case there is some inline style');\n    content = grunt.helper('replace', content, /url\\(\\s*['\"]?([^'\"\\)]+)['\"]?\\s*\\)/gm);\n\n    return content;\n  });\n\n  //\n  // global replace handler, takes a file content a regexp to macth with. The\n  // regexp should capture the assets relative filepath, it is then compared to\n  // the list of files on the filesystem to guess the actual revision of a file\n  //\n  grunt.registerHelper('replace', function(content, regexp) {\n    return content.replace(regexp, function(match, src) {\n      //do not touch external files or the root\n      if ( src.match(/\\/\\//) || src.match(/^\\/$/)) {\n        return match;\n      }\n\n      // Consider reference from site root\n      if ( src.match(/^\\//) ) {\n        src = src.substr(1);\n      }\n\n      var basename = path.basename(src);\n      var dirname = path.dirname(src);\n\n      // XXX files won't change, the filepath should filter the original list\n      // of cached files (we need to treat the filename collision -- i.e. 2 files with same names\n      // in different subdirectories)\n      var filepaths = grunt.file.expand(path.join('**/*') + basename);\n      var filepath = filepaths.filter(function(f) { return dirname === path.dirname(f);})[0];\n\n      // not a file in temp, skip it\n      if ( !filepath ) {\n        return match;\n      }\n      var filename = path.basename(filepath);\n      // handle the relative prefix (with always unix like path even on win32)\n      filename = [dirname, filename].join('/');\n\n      // if file not exists probaly was concatenated into another file so skip it\n      if ( !filename ) {\n        return '';\n      }\n\n      var res = match.replace(src, filename);\n      // output some verbose info on what get replaced\n      grunt.log\n        .ok(src)\n        .writeln('was ' + match)\n        .writeln('now ' + res);\n\n      return res;\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/yeoman.js":"var fs    = require('fs');\nvar join  = require('path').join;\nvar util  = require('util');\nvar which = require('which');\n\n// ant build script has a nice notion of environment, this defaults to\n// production. And we only support env=prod for now.\n//\n// not implemented tasks (add noop waithing for their impl): manifest\n\nmodule.exports = function(grunt) {\n\n  // External grunt plugin:\n  //\n  // - jasmine task: https://github.com/creynders/grunt-jasmine-task\n  //\n  // note: We need to use loadTasks instead of loadNpmTasks, otherwise will try\n  // to load relative to gruntfile node_modules, this would require user to\n  // install manually. So we load tasks specifically from our node_modules,\n  // with abs path.\n  //\n  grunt.loadTasks(join(__dirname, '../node_modules/grunt-jasmine-task/tasks'));\n  grunt.loadTasks(join(__dirname, '../node_modules/grunt-mocha/tasks'));\n  grunt.loadTasks(join(__dirname, '../node_modules/grunt-contrib-coffee/tasks'));\n\n  // build targets: these are equivalent to grunt alias except that we defined\n  // a single task and use arguments to trigger the appropriate target\n  //\n  // - build    - no html compression, no usemin-handler task\n  // - usemin   - (default) same as build but parsing config from markup\n  // - text     - same as usemin but without image (png/jpg) optimizing\n  // - buildkit - minor html optimizations, all html whitespace/comments\n  //              maintained (todo: inline script/style minified)\n  // - basics   - same as buildkit plus minor html optimizations\n  // - minify   - same as build plus full html minification\n  //\n  // - test     - same as default build plus but conditionally runs compass /\n  //              manifest task depending on whether or not compass / phantomjs binaries are\n  //              available within the path.  During the checking process, we output warning\n  //              infos about missing deps. It might make sense to make it the default (img\n  //              task internally does this check)\n  var targets = {\n    default   : '               rjs concat css min img rev usemin manifest',\n    usemin    : 'usemin-handler rjs concat css min img rev usemin manifest',\n    text      : 'usemin-handler rjs concat css min     rev usemin manifest',\n    buildkit  : 'usemin-handler rjs concat css min img rev usemin manifest html:buildkit',\n    basics    : 'usemin-handler rjs concat css min img rev usemin manifest html:basics',\n    minify    : 'usemin-handler rjs concat css min img rev usemin manifest html:compress',\n    test      : 'usemin-handler rjs concat css min img rev usemin manifest'\n  };\n\n  var targetList = grunt.log.wordlist(Object.keys(targets));\n  grunt.registerTask('build', 'Run a predefined target - build:<target> \\n' + targetList, function(target) {\n    var valid = Object.keys(targets);\n    target = target || 'usemin';\n\n    if ( valid.indexOf( target ) === -1 ) {\n      grunt.log\n        .error('Not a valid target')\n        .error(grunt.helper('invalid targets', targets));\n      return false;\n    }\n\n    var tasks = ['intro', 'clean coffee compass mkdirs', targets[target], 'copy time'].join(' ');\n\n    // Conditionally remove compass / manifest task if either compass or\n    // phantomjs binary is missing. Done only for `test` target (specifically\n    // used for our `npm test`). For each, output warning infos.\n    if( target === 'test' ) {\n      tasks = grunt.helper( 'build:skip', tasks, 'compass' );\n      tasks = grunt.helper( 'build:skip', tasks, 'phantomjs', 'manifest' );\n    }\n\n    grunt.log.subhead('Running ' + target + ' target')\n      .writeln('  - ' + grunt.log.wordlist(tasks.split(' '), { separator: ' ' }));\n\n\n    grunt.task.run(tasks);\n  });\n\n  grunt.registerHelper('invalid targets', function(valid, code) {\n    var msg = Object.keys(valid).map(function(key) {\n      if ( /pre|post/.test( key ) ) {\n        return '';\n      }\n      return grunt.helper('pad', key, 10) + '# '+ valid[key];\n    }).join(grunt.util.linefeed);\n\n    var err = new Error(grunt.util.linefeed + msg);\n    err.code = code || 3;\n    return err;\n  });\n\n  // Helper to conditionally remove a given task from the provided list of\n  // `tasks` (as a String). A `cmd` and `task` Strings should be provided,\n  // if `task` is omitted, it then takes the same value of the `cmd` one.\n  //\n  // When a binary is known as non available, and that the task is skipped,\n  // this helper also output warning info to the user.\n  //\n  // - tasks   - String list of tasks to be run\n  // - cmd     - The String name of the binary to check against the system.\n  // - task    - (optional) A string name to define the specific task to remove\n  //             from the returned tasks list. If undefined, is the same than\n  //             `binary`.\n  //\n  // Returns optionally modified `tasks` String.\n  grunt.registerHelper('build:skip', function(tasks, cmd, task) {\n      try {\n        which.sync(cmd);\n      } catch(err) {\n        grunt.helper('not installed', cmd);\n        tasks = tasks.replace(task || cmd, '');\n      }\n\n      return tasks;\n  });\n\n  grunt.registerHelper('pad', function pad(str, max) {\n    return str.length > max ? str :\n        str + new Array(max - str.length + 1).join(' ');\n  });\n\n  var now = +new Date();\n  grunt.registerTask('time', 'Print sucess status with elapsed time', function() {\n    grunt.log.ok('Build success. Done in ' + ((+new Date() - now) / 1000) + 's');\n  });\n\n  // Output some size info about a file, from a stat object.\n  grunt.registerHelper('min_max_stat', function(min, max) {\n    min = typeof min === 'string' ? fs.statSync(min) : min;\n    max = typeof max === 'string' ? fs.statSync(max) : max;\n    grunt.log.writeln('Uncompressed size: ' + String(max.size).green + ' bytes.');\n    grunt.log.writeln('Compressed size: ' + String(min.size).green + ' bytes minified.');\n  });\n\n  // Output some info on given object, using util.inspect, using colorized output.\n  grunt.registerHelper('inspect', function(o) {\n    return util.inspect(o, false, 4, true);\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/lib/plugins/insight.js":"var fs = require('fs'),\n    join = require('path').join,\n    exec = require('child_process').exec,\n    colors = require('colors'),\n    prompt = require('prompt');\n\n/**\n * Records the give cmd to Insight.\n *\n * It's assumed yeomaninsight.py is installed globally as\n * /usr/local/bin/_yeomaninsight (or platform equivalent). A full cmd would\n * might look like: _yeomaninsight -n yeoman -v 0.0.1 record cmd cmd2\n *\n * @param {string} cmd The full command line that was run.\n * @param {Function} callback Callback to call when Insight is done.\n */\nfunction invokeInsight(cmd, callback) {\n  exec(cmd, function(err, stdout, stderr) {\n    if (err) {\n      console.log(stderr);\n      return callback(err);\n    }\n    callback();\n  });\n}\n\nmodule.exports = {\n  init: function(opts) {\n\n    var insight = {\n      // Store records in user's home dir (e.g. /Users/username/.yeoman/insight)\n      logFile: join(opts.getUserHome(), '.' + opts.pkgname, 'insight', '.log'),\n      script: '_' + opts.pkgname + 'insight',\n      recordArgs: ['-n', opts.pkgname, '-v', opts.pkgversion, 'record'],\n      record: invokeInsight\n    };\n\n    // Example: _yeomaninsight -n yeoman -v 0.9.4 record cmd cmd2.\n    var cmdStr = insight.script + ' ' +\n                 insight.recordArgs.concat(opts.cmds).join(' ');\n\n    fs.stat(insight.logFile, function(err, stats) {\n      // Error means file doesn't exist and this is the first run.\n      // Go through stat opt-in flow.\n      if (!err)  {\n        return insight.record(cmdStr, opts.cb);\n      }\n\n/*jshint multistr:true */\nvar msg = \"\\\n==========================================================================\".grey + \"\\n\\\nWe're constantly looking for ways to make \".yellow + opts.pkgname.bold.red + \" better! \\n\\\nMay we anonymously report usage statistics to improve the tool over time? \\n\\\nMore info: yeoman.io/insight.html & http://yeoman.io\".yellow + \"\\n\\\n==========================================================================\".grey;\n\n      prompt.message = '[' + '?'.green + ']';\n      prompt.delimiter = ' ';\n\n      var properties = [{\n        name: 'optin',\n        message: '[Y/n]: ',\n        \"default\": 'Y',\n        validator: /^[yntf]{1}/i,\n        empty: false\n      }];\n\n      prompt.start();\n      console.log(msg);\n      prompt.get(properties, function(err, result) {\n        if (err) {\n          return opts.cb(err);\n        }\n\n        if (/n/i.test(result.optin)) {\n          cmdStr = insight.script + ' ' +\n                   insight.recordArgs.concat(['NO_STATS']).join(' ');\n          return insight.record(cmdStr, opts.cb);\n        }\n\n        insight.record(cmdStr, opts.cb);\n      });\n\n    });\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/lib/plugins/updater.js":"// Updater.js: npm version checker and updater for packages\n// @author: Addy Osmani and Sindre Sorhus\n// @inspired by: npm, npm-latest\n//\n// Sample usage:\n//\n// Query for the latest update type\n// updater.getUpdate({ name: 'grunt', version: pkg.version }, function( error, update ) {\n//   console.log('Update checking complete');\n// });\n//\n// Alternatively, if you just want to pass in a package.json\n// file directly, you can simply do:\n//\n// updater.getUpdate({ localPackageUrl: '../package.json' }, function( error, update ) {\n//   console.log('Update checking complete');\n// });\n//\n// Both will either return patch, minor, major or latest. These\n// correspond to:\n//\n// patch 0.0.x: Forced auto-update with opt-out\n// ability. Since it should only contain backwards\n// compatible bugfixes.\n//\n// minor 0.x.0: Update prompts (with auto-update\n// after a set time) with ability to opt out of\n// auto-update.\n//\n// major: x.0.0: Update prompts (no time-limit),\n// since this can contain backwards incompatible changes.\n//\n// latest: you are already up to date\n//\n\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar exec = require('child_process').exec;\nvar EventEmitter = require('events').EventEmitter;\nvar request = require('request');\nvar colors = require('colors');\nvar prompt = require('prompt');\n\n\nvar updater = module.exports;\n\n\nvar config = (function() {\n  var mkdirp = require('mkdirp');\n  var homeDir = process.env[ process.platform === 'win32' ? 'USERPROFILE' : 'HOME' ];\n  var folderPath = path.join( homeDir, '.config', 'npm-updater' );\n  // Function, since _packageName is not available when this is init'd\n  var filename = function() {\n    return updater._packageName + '.json';\n  };\n\n  var loadConfig = function() {\n    try {\n      return JSON.parse( fs.readFileSync( path.join( folderPath, filename() ), 'utf-8' ) || {} );\n    } catch ( err ) {\n      // Create dir if it doesn't exist\n      if ( err.errno === 34 ) {\n        mkdirp.sync( folderPath );\n        return {};\n      }\n    }\n  };\n\n  return {\n    get: function( key ) {\n      return loadConfig()[ key ];\n    },\n    set: function( key, val ) {\n      var config = loadConfig();\n      config[ key ] = val;\n      fs.writeFileSync( path.join( folderPath, filename() ), JSON.stringify( config, null, '\\t' ) );\n    }\n  };\n})();\n\n\n\n\n// Registry end-point\n// Alternative registry mirrors\n// http://85.10.209.91/%s\n// http://165.225.128.50:8000/%s\nupdater.registryUrl = 'http://registry.npmjs.org/%s';\n\n// How often the updater should check for updates\nupdater.updateCheckInterval = 1000 * 60 * 60 * 24; // 1 day\n\n// How long it should wait until force auto-update\nupdater.updatePromptTimeLimit = 1000 * 60 * 60 * 24 * 7; // 1 week\n\n\n// Prompt for update\nupdater.promptUpdate = function promptUpdate( cb ) {\n  prompt.start();\n  prompt.message = 'yeoman'.red;\n  prompt.get([{\n    name: 'shouldUpdate',\n    message: ( 'Do you want to upgrade ' + this._packageName + '?' ).yellow\n  }], function( err, result ) {\n    cb( !err && /^y/i.test( result.shouldUpdate ) );\n  });\n};\n\n\n// TODO(sindresorhus): Docs\n// Prefilter to be overriden if custom logic is needed\nupdater.shouldUpdate = function shouldUpdate( update, cb ) {\n  var severity = update.severity;\n\n  console.log('Update available: ' + update.latest.green +\n              (' (current: ' + update.current + ')').grey );\n\n  if ( config.get('optOut') === true ) {\n    console.log('You have opted out of automatic updates');\n    console.log('Run `npm update -g yeoman` to update');\n    return cb( false );\n  }\n\n  if ( severity === 'patch' ) {\n    cb( true );\n  }\n\n  if ( severity === 'minor' ) {\n    // Force auto-update if it's past the set time limit\n    if ( new Date() - new Date( update.date ) > this.updatePromptTimeLimit ) {\n      console.log( 'Forcing update because it\\'s been too long since last'.red );\n      return cb( true );\n    }\n\n    this.promptUpdate(function( shouldUpdate ) {\n      cb( shouldUpdate );\n    });\n  }\n\n  if ( severity === 'major' ) {\n    this.promptUpdate(function( shouldUpdate ) {\n      cb( shouldUpdate );\n    });\n  }\n};\n\n\n//\n// updater.getUpdate()\n// Returns the severity of the latest update available\n//\n// Supported options:\n//\n// @options.name: package name\n//\n// @options.version: local package version\n//\n// @options.localPackageUrl: the url to a local package to be\n// checked against if no package name or version are supplied\n//\n// cb: callback for when the update checks and update is complete\n\nupdater.getUpdate = function getUpdate( options, cb ) {\n  var localPackage, url;\n  var controller = new EventEmitter();\n\n  cb = cb || function() {};\n\n  // Step 1: We need a package name and version to work off.\n\n  // Ideally, supply us with the package name and version\n  if ( options.name === undefined || options.version === undefined ) {\n    // If not, we'll ascertain from a local package.json file\n    if ( options.localPackageUrl ) {\n      localPackage = require( options.localPackageUrl );\n      options.name = localPackage.name;\n      options.version = localPackage.version;\n    } else {\n      cb();\n      return console.error('No package name/version or local package supplied');\n    }\n  }\n\n  // Expose the packageName internally, but still\n  // make it accessible if somone would need it\n  this._packageName = options.name;\n\n  // Create the `optOut` option, so it's easy to switch the flag\n  if ( config.get('optOut') === undefined ) {\n    config.set( 'optOut', false );\n  }\n\n  // Only check for updates on a set interval\n  if ( new Date() - config.get('lastUpdateCheck') < this.updateCheckInterval ) {\n    cb();\n    return;\n  }\n\n  console.log('Starting update check...');\n\n  // Update the last update check date\n  config.set( 'lastUpdateCheck', +new Date() );\n\n  // Step 2: Query the NPM registry for the latest package\n  url = util.format( this.registryUrl, options.name );\n\n  request({ url: url, json: true }, function( error, response, body ) {\n    var latest, update;\n\n    // TODO(sindresorhus): Look into the best way to output errors, only cb or cb + emit?\n\n    // Fetch issue incurred\n    if ( error ) {\n      controller.emit('fetchError', {\n        message: error.message,\n        httpCode: response && response.statusCode\n      });\n\n      cb( error );\n\n      return;\n    }\n\n    // Whoops, package not found\n    if ( body.error ) {\n      controller.emit('npmError', {\n          errorType: body.error, // not_found etc\n          reason: body.reason // additional reason\n      });\n\n      cb( error );\n\n      return;\n    }\n\n    // Step 3: Package found, lets compare versions\n    latest = Object.keys( body.time ).reverse()[0];\n\n    // Details to expose about the update\n    update = {\n      latest: latest,\n      date: body.time[ latest ],\n      current: options.version,\n      severity: this.parseUpdateType( options.version, latest )\n    };\n\n    if ( update.severity !== 'latest' ) {\n      this.shouldUpdate( update, function( shouldUpdate ) {\n        if ( shouldUpdate ) {\n          this.updatePackage( options.name, function( err, data ) {\n            if ( err ) {\n              console.error( '\\nUpdate error', err );\n            } else {\n              console.log( '\\nUpdated successfully!'.green );\n            }\n\n            cb( err, update );\n          });\n        } else {\n          cb( err, update );\n        }\n      }.bind(this));\n    } else {\n      cb();\n    }\n  }.bind(this));\n};\n\n\n\n// Compare a local package version and remote package version\n// to discover what type of update (major, minor, patch) is\n// available.\nupdater.parseUpdateType = function parseUpdateType( current, remoteVersion ) {\n  var current, remote;\n\n  if ( current  === remoteVersion ) {\n    return 'latest';\n  }\n\n  current = current.split('.');\n  remote  = remoteVersion.split('.');\n\n  if ( remote[0] > current[0] ) {\n    return 'major';\n  } else if ( remote[1] > current[1] ) {\n    return 'minor';\n  } else if ( remote[2] > current[2] ) {\n    return 'patch';\n  } else{\n    return 'Update comparison error';\n  }\n};\n\n\n// Run `npm update` against a specific package name\nupdater.updatePackage = function updatePackage( packageName, cb ) {\n  // TODO(sindresorhus): Find a better solution for local packages\n  // Something like going up filestructure until node_modules folder\n  var child = exec( 'npm update -g ' + packageName, cb );\n  console.log( 'Updating ' + packageName + '\\n' );\n  child.stdout.pipe( process.stdout );\n  child.stderr.pipe( process.stderr );\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/lib/support/confess.js":"var fs = require('fs');\nvar confess = {\n\n  run: function () {\n    var cliConfig = {};\n    if (!this.processArgs(cliConfig, [\n      {\n        name: 'url',\n        def: 'http://google.com',\n        req: true,\n        desc: 'the URL of the app to cache'\n      }, {\n        name: 'task',\n        def: 'appcache',\n        req: false,\n        desc: 'the task to perform',\n        oneof: ['performance', 'appcache', 'cssproperties']\n      }, {\n        name: 'configFile',\n        def: 'config.json',\n        req: false,\n        desc: 'a local configuration file of further confess settings'\n      },\n    ])) {\n      phantom.exit();\n      return;\n    }\n    this.config = this.mergeConfig(cliConfig, cliConfig.configFile);\n    var task = this[this.config.task];\n    this.load(this.config, task, this);\n  },\n\n  performance: {\n    resources: [],\n    onLoadStarted: function (page, config) {\n      if (!this.performance.start) {\n        this.performance.start = new Date().getTime();\n      }\n    },\n    onResourceRequested: function (page, config, request) {\n      var now = new Date().getTime();\n      this.performance.resources[request.id] = {\n        id: request.id,\n        url: request.url,\n        request: request,\n        responses: {},\n        duration: '-',\n        times: {\n          request: now\n        }\n      };\n      if (!this.performance.start || now < this.performance.start) {\n        this.performance.start = now;\n      }\n    },\n    onResourceReceived: function (page, config, response) {\n      var now = new Date().getTime(),\n        resource = this.performance.resources[response.id];\n      resource.responses[response.stage] = response;\n      if (!resource.times[response.stage]) {\n        resource.times[response.stage] = now;\n        resource.duration = now - resource.times.request;\n      }\n      if (response.bodySize) {\n        resource.size = response.bodySize;\n      } else if (!resource.size) {\n        response.headers.forEach(function (header) {\n          if (header.name.toLowerCase()=='content-length') {\n            resource.size = parseInt(header.value);\n          }\n        });\n      }\n    },\n    onLoadFinished: function (page, config, status) {\n      var start = this.performance.start,\n        finish =  new Date().getTime(),\n        resources = this.performance.resources,\n        slowest, fastest, totalDuration = 0,\n        largest, smallest, totalSize = 0,\n        missingSize = false,\n        elapsed = finish - start,\n        length = 104,\n        ratio = length / elapsed,\n        bar;\n\n      resources.forEach(function (resource) {\n        if (!resource.times.start) {\n          resource.times.start = resource.times.end;\n        }\n        if (!slowest || resource.duration > slowest.duration) {\n          slowest = resource;\n        }\n        if (!fastest || resource.duration < fastest.duration) {\n          fastest = resource;\n        }\n        totalDuration += resource.duration;\n\n        if (resource.size) {\n          if (!largest || resource.size > largest.size) {\n            largest = resource;\n          }\n          if (!smallest || resource.size < smallest.size) {\n            smallest = resource;\n          }\n          totalSize += resource.size;\n        } else {\n          resource.size = '-';\n          missingSize = true;\n        }\n      });\n\n      if (config.verbose) {\n        console.log('');\n        this.emitConfig(config, '');\n      }\n      console.log('');\n      console.log('Elapsed load time: ' + this.pad(elapsed, 6) + 'ms');\n      console.log('   # of resources: ' + this.pad(resources.length-1, 8));\n      console.log('');\n      console.log(' Fastest resource: ' + this.pad(fastest.duration, 6) + 'ms; ' + this.truncate(fastest.url));\n      console.log(' Slowest resource: ' + this.pad(slowest.duration, 6) + 'ms; ' + this.truncate(slowest.url));\n      console.log('  Total resources: ' + this.pad(totalDuration, 6) + 'ms');\n      console.log('');\n      console.log('Smallest resource: ' + this.pad(smallest.size, 7) + 'b; ' + this.truncate(smallest.url));\n      console.log(' Largest resource: ' + this.pad(largest.size, 7) + 'b; ' + this.truncate(largest.url));\n      console.log('  Total resources: ' + this.pad(totalSize, 7) + 'b' + (missingSize ? '; (at least)' : ''));\n      if (config.verbose) {\n        console.log('');\n        resources.forEach(function (resource) {\n          bar = this.repeat(' ', (resource.times.request - start) * ratio) +\n              this.repeat('-', (resource.times.start - resource.times.request) * ratio) +\n              this.repeat('=', (resource.times.end - resource.times.start) * ratio)\n          ;\n          bar = bar.substr(0, length) + this.repeat(' ', length - bar.length);\n          console.log(this.pad(resource.id, 3) + '|' + bar + '|');\n        }, this);\n        console.log('');\n        resources.forEach(function (resource) {\n          console.log(\n            this.pad(resource.id, 3) + ': ' +\n            this.pad(resource.duration, 6) + 'ms; ' +\n            this.pad(resource.size, 7) + 'b; ' +\n            this.truncate(resource.url, 84)\n          );\n        }, this);\n      }\n    }\n  },\n\n  appcache: {\n    resourceUrls: {},\n    onResourceRequested: function (page, config, request) {\n      if (config.appcache.urlsFromRequests) {\n        this.appcache.resourceUrls[request.url] = true;\n      }\n    },\n    onLoadFinished: function (page, config, status) {\n      if (status!='success') {\n        console.log('# FAILED TO LOAD');\n        return;\n      }\n\n      var key, key2, url,\n        neverMatch = \"(?!a)a\",\n        cacheRegex = new RegExp(config.appcache.cacheFilter || neverMatch),\n        networkRegex = new RegExp(config.appcache.networkFilter || neverMatch);\n\n      console.log('CACHE MANIFEST');\n      console.log('');\n      console.log('# Time: ' + new Date());\n      if (config.verbose) {\n        console.log('# This manifest was created by confess.js, http://github.com/jamesgpearce/confess');\n        console.log('#');\n        console.log('# Retrieved URL: ' + this.getFinalUrl(page));\n        console.log('# User-agent: ' + page.settings.userAgent);\n        console.log('#');\n        this.emitConfig(config, '# ');\n      }\n      console.log('');\n      console.log('CACHE:');\n\n      if (config.appcache.urlsFromDocument) {\n        for (url in this.getResourceUrls(page)) {\n          this.appcache.resourceUrls[url] = true;\n        }\n      }\n      for (url in this.appcache.resourceUrls) {\n        if (cacheRegex.test(url) && !networkRegex.test(url)) {\n          console.log(url);\n        }\n      };\n      console.log('');\n      console.log('NETWORK:');\n      console.log('*');\n    }\n  },\n\n  cssproperties: {\n    resourceUrls: {},\n    onResourceRequested: function (page, config, request) {\n      if (config.appcache.urlsFromRequests) {\n        this.appcache.resourceUrls[request.url] = true;\n      }\n    },\n    onLoadFinished: function (page, config, status) {\n      if (status!='success') {\n        console.log('# FAILED TO LOAD');\n        return;\n      }\n      if (config.verbose) {\n        console.log('');\n        this.emitConfig(config, '');\n      }\n      console.log('');\n      console.log('CSS properties used:');\n      for (property in this.getCssProperties(page)) {\n        console.log(property);\n      }\n    }\n  },\n\n  getFinalUrl: function (page) {\n    return page.evaluate(function () {\n      return document.location.toString();\n    });\n  },\n\n  getResourceUrls: function (page) {\n    return page.evaluate(function () {\n      var\n        // resources referenced in DOM\n        // notable exceptions: iframes, rss, links\n        selectors = [\n          ['script', 'src'],\n          ['img', 'src'],\n          ['link[rel=\"stylesheet\"]', 'href']\n        ],\n\n        resources = {},\n        baseScheme = document.location.toString().split(\"//\")[0],\n        tallyResource = function (url) {\n          if (url && url.substr(0,5)!='data:') {\n            if (url.substr(0, 2)=='//') {\n              url = baseScheme + url;\n            }\n            if (!resources[url]) {\n              resources[url] = 0;\n            }\n            resources[url]++;\n          }\n        },\n\n        elements, elementsLength, e,\n        stylesheets, stylesheetsLength, ss,\n        rules, rulesLength, r,\n        style, styleLength, s,\n        computed, computedLength, c,\n        value;\n\n      // attributes in DOM\n      selectors.forEach(function (selectorPair) {\n        elements = document.querySelectorAll(selectorPair[0]);\n        for (e = 0, elementsLength = elements.length; e < elementsLength; e++) {\n          tallyResource(elements[e].getAttribute(selectorPair[1]));\n        };\n      });\n\n      // URLs in stylesheets\n      stylesheets = document.styleSheets;\n      for (ss = 0, stylesheetsLength = stylesheets.length; ss < stylesheetsLength; ss++) {\n        rules = stylesheets[ss].rules;\n        if (!rules) { continue; }\n        for (r = 0, rulesLength = rules.length; r < rulesLength; r++) {\n          if (!rules[r]['style']) { continue; }\n          style = rules[r].style;\n          for (s = 0, styleLength = style.length; s < styleLength; s++) {\n            value = style.getPropertyCSSValue(style[s]);\n            if (value && value.primitiveType == CSSPrimitiveValue.CSS_URI) {\n              tallyResource(value.getStringValue());\n            }\n          }\n        };\n      };\n\n      // URLs in styles on DOM\n      elements = document.querySelectorAll('*');\n      for (e = 0, elementsLength = elements.length; e < elementsLength; e++) {\n        computed = elements[e].ownerDocument.defaultView.getComputedStyle(elements[e], '');\n        for (c = 0, computedLength = computed.length; c < computedLength; c++) {\n          value = computed.getPropertyCSSValue(computed[c]);\n          if (value && value.primitiveType == CSSPrimitiveValue.CSS_URI) {\n            tallyResource(value.getStringValue());\n          }\n        }\n      };\n\n      return resources;\n    });\n  },\n\n  getCssProperties: function (page) {\n    return page.evaluate(function () {\n      var properties = {},\n        tallyProperty = function (property) {\n          if (!properties[property]) {\n            properties[property] = 0;\n          }\n          properties[property]++;\n        },\n        stylesheets, stylesheetsLength, ss,\n        rules, rulesLength, r,\n        style, styleLength, s,\n        property;\n\n      // properties in stylesheets\n      stylesheets = document.styleSheets;\n      for (ss = 0, stylesheetsLength = stylesheets.length; ss < stylesheetsLength; ss++) {\n        rules = stylesheets[ss].rules;\n        if (!rules) { continue; }\n        for (r = 0, rulesLength = rules.length; r < rulesLength; r++) {\n          if (!rules[r]['style']) { continue; }\n          style = rules[r].style;\n          for (s = 0, styleLength = style.length; s < styleLength; s++) {\n            tallyProperty(style[s]);\n          }\n        }\n      }\n\n      // properties in styles on DOM\n      elements = document.querySelectorAll('*');\n      for (e = 0, elementsLength = elements.length; e < elementsLength; e++) {\n        rules = elements[e].ownerDocument.defaultView.getMatchedCSSRules(elements[e], '');\n        if (!rules) { continue; }\n        for (r = 0, rulesLength = rules.length; r < rulesLength; r++) {\n          if (!rules[r]['style']) { continue; }\n          style = rules[r].style;\n          for (s = 0, styleLength = style.length; s < styleLength; s++) {\n            tallyProperty(style[s]);\n          }\n        }\n      }\n      return properties;\n    });\n  },\n\n  emitConfig: function (config, prefix) {\n    console.log(prefix + 'Config:');\n    for (key in config) {\n       if (config[key].constructor === Object) {\n        if (key===config.task) {\n          console.log(prefix + ' ' + key + ':');\n          for (key2 in config[key]) {\n            console.log(prefix + '  ' + key2 + ': ' + config[key][key2]);\n          }\n        }\n       } else {\n         console.log(prefix + ' ' + key + ': ' + config[key]);\n       }\n     }\n  },\n\n  load: function (config, task, scope) {\n    var page = new WebPage(),\n      event;\n    if (config.consolePrefix) {\n      page.onConsoleMessage = function (msg, line, src) {\n        console.log(config.consolePrefix + ' ' + msg + ' (' + src + ', #' + line + ')');\n      }\n    }\n    if (config.userAgent && config.userAgent != \"default\") {\n      if (config.userAgentAliases[config.userAgent]) {\n        config.userAgent = config.userAgentAliases[config.userAgent];\n      }\n      page.settings.userAgent = config.userAgent;\n    }\n    ['onInitialized', 'onLoadStarted', 'onResourceRequested', 'onResourceReceived']\n    .forEach(function (event) {\n      if (task[event]) {\n        page[event] = function () {\n          var args = [page, config],\n            a, aL;\n          for (a = 0, aL = arguments.length; a < aL; a++) {\n            args.push(arguments[a]);\n          }\n          task[event].apply(scope, args);\n        };\n      }\n    });\n    if (task.onLoadFinished) {\n      page.onLoadFinished = function (status) {\n        if (config.wait) {\n          setTimeout(\n            function () {\n              task.onLoadFinished.call(scope, page, config, status);\n              phantom.exit();\n            },\n            config.wait\n          );\n        } else {\n          task.onLoadFinished.call(scope, page, config, status);\n          phantom.exit();\n        }\n      };\n    } else {\n      page.onLoadFinished = function (status) {\n        phantom.exit();\n      }\n    }\n    page.open(config.url);\n  },\n\n  processArgs: function (config, contract) {\n    var a = 0;\n    var ok = true;\n    contract.forEach(function(argument) {\n      if (a < phantom.args.length) {\n        config[argument.name] = phantom.args[a];\n      } else {\n        if (argument.req) {\n          console.log('\"' + argument.name + '\" argument is required. This ' + argument.desc + '.');\n          ok = false;\n        } else {\n          config[argument.name] = argument.def;\n        }\n      }\n      if (argument.oneof && argument.oneof.indexOf(config[argument.name])==-1) {\n        console.log('\"' + argument.name + '\" argument must be one of: ' + argument.oneof.join(', '));\n        ok = false;\n      }\n      a++;\n    });\n    return ok;\n  },\n\n  mergeConfig: function (config, configFile) {\n    if (!fs.exists(configFile)) {\n       configFile = \"config.json\";\n    }\n    var result = JSON.parse(fs.read(configFile)),\n      key;\n    for (key in config) {\n      result[key] = config[key];\n    }\n    return result;\n  },\n\n  truncate: function (str, length) {\n    length = length || 80;\n    if (str.length <= length) {\n      return str;\n    }\n    var half = length / 2;\n    return str.substr(0, half-2) + '...' + str.substr(str.length-half+1);\n  },\n\n  pad: function (str, length) {\n    var padded = str.toString();\n    if (padded.length > length) {\n      return this.pad(padded, length * 2);\n    }\n    return this.repeat(' ', length - padded.length) + padded;\n  },\n\n  repeat: function (chr, length) {\n    // Add +1 to ensure the _correct_ number of \"chr\" are repeated\n    return (new Array(length + 1)).join(chr);\n  }\n\n};\n\nconfess.run();\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/lib/utils/fetch.js":"var fs = require('fs'),\n  path = require('path'),\n  colors = require('colors'),\n  zlib = require('zlib'),\n  request = require('request'),\n  tar = require('tar');\n\n// Check if we're behind some kind of proxy.\nvar proxy = process.env.http_proxy || process.env.HTTP_PROXY ||\n    process.env.https_proxy || process.env.HTTPS_PROXY || '';\n\n// heavily based on npm's util/untar.js file\nfunction fetch(tarball, target, cb) {\n  var now = +new Date();\n\n  var log = this.log\n    .subhead('Fetching ' + tarball)\n    .writeln('This might take a few moment'.yellow);\n\n  // tarball untar opts\n  var extractOpts = { type: 'Directory', path: target, strip: 1 };\n\n  // remote request --> zlib.Unzip() --> untar into h5bp/root\n  var req = fetch.request.get(tarball).on('error', cb);\n\n  req.on('data', function() { log.write('.'); }).on('end', function() {\n    log.ok().writeln();\n    log.ok( ('Done in ' + (+new Date() - now) / 1000 + 's.').green );\n  });\n\n  req\n    // first gzip\n    .pipe(zlib.Unzip())\n    .on('error', function(err) {\n      console.error('unzip error', err);\n      cb(err);\n    })\n    // then tar extract into h5bp/root\n    .pipe(tar.Extract(extractOpts))\n    .on('entry', function(entry) {\n      entry.props.uid = entry.uid = 501;\n      entry.props.gid = entry.gid = 20;\n    })\n    .on('error', function(err) {\n      console.error('untar error', err);\n      cb(err);\n    })\n    .on('close', function() {\n      log.writeln().ok( ('Done in ' + extractOpts.path).green ).writeln();\n      cb();\n    });\n}\n\n\nmodule.exports = fetch;\n\n// re-expose the request with proxy defaults, so that we can\n// reuse this instance of request.\nfetch.request = request.defaults({ proxy: proxy });\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/init/yeoman.js":"\nvar fs = require('fs'),\n  path = require('path'),\n  colors = require('colors'),\n  yeoman = require('../../'),\n  grunt = require('grunt'),\n  utils = yeoman.utils;\n\n// top level export\nvar template = module.exports;\n\n// get back the resolved generator name to invoke\nvar name = yeoman.generators.name;\n\n// and associated cli options (--help, --foo, ...)\nvar opts = yeoman.generators.options;\n\n// strip back args from any `init:` prefix\ngrunt.cli.tasks = grunt.cli.tasks.map(function(arg) {\n  return arg.replace(/^init:/, '');\n});\n\nif(!name && !opts.help) {\n  yeoman.generators.name = 'app';\n}\n\n// Basic template description.\ntemplate.description = 'Init a new project or components';\n\n// warnOn, specifics to resolved generator.  Any existing file or directory\n// matching this wildcard will cause a warning.\n//\n// Bypass on --help\nif(!opts.help) {\n  template.warnOn = yeoman.generators.warnOn(grunt);\n}\n\n// Template-specific notes to be displayed before question prompts.\ntemplate.notes = '\\n'; //... More notes to come here ...'.yellow;\n\n// The actual grunt init template. We need to support:\n//\n// yeoman init\n// yeoman init backbone\n// yeoman init backbone:model modelName\n//\n// Handles the specific case of default generator on `init` (without generator\n// name).\ntemplate.template = function _template(grunt, init, cb) {\n\n  // delegate the groundwork of scaffolding to the generator layer\n  return yeoman.generators.init(grunt);\n};\n","/home/travis/build/npmtest/node-npmtest-yeoman/node_modules/yeoman/tasks/livereload/livereload.js":"// https://github.com/livereload/livereload-js/raw/master/dist/livereload.js\n(function() {\nvar __customevents = {}, __protocol = {}, __connector = {}, __timer = {}, __options = {}, __reloader = {}, __livereload = {}, __less = {}, __startup = {};\n\n// customevents\nvar CustomEvents;\nCustomEvents = {\n  bind: function(element, eventName, handler) {\n    if (element.addEventListener) {\n      return element.addEventListener(eventName, handler, false);\n    } else if (element.attachEvent) {\n      element[eventName] = 1;\n      return element.attachEvent('onpropertychange', function(event) {\n        if (event.propertyName === eventName) {\n          return handler();\n        }\n      });\n    } else {\n      throw new Error(\"Attempt to attach custom event \" + eventName + \" to something which isn't a DOMElement\");\n    }\n  },\n  fire: function(element, eventName) {\n    var event;\n    if (element.addEventListener) {\n      event = document.createEvent('HTMLEvents');\n      event.initEvent(eventName, true, true);\n      return document.dispatchEvent(event);\n    } else if (element.attachEvent) {\n      if (element[eventName]) {\n        return element[eventName]++;\n      }\n    } else {\n      throw new Error(\"Attempt to fire custom event \" + eventName + \" on something which isn't a DOMElement\");\n    }\n  }\n};\n__customevents.bind = CustomEvents.bind;\n__customevents.fire = CustomEvents.fire;\n\n// protocol\nvar PROTOCOL_6, PROTOCOL_7, Parser, ProtocolError;\nvar __indexOf = Array.prototype.indexOf || function(item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this[i] === item) return i;\n  }\n  return -1;\n};\n__protocol.PROTOCOL_6 = PROTOCOL_6 = 'http://livereload.com/protocols/official-6';\n__protocol.PROTOCOL_7 = PROTOCOL_7 = 'http://livereload.com/protocols/official-7';\n__protocol.ProtocolError = ProtocolError = (function() {\n  function ProtocolError(reason, data) {\n    this.message = \"LiveReload protocol error (\" + reason + \") after receiving data: \\\"\" + data + \"\\\".\";\n  }\n  return ProtocolError;\n})();\n__protocol.Parser = Parser = (function() {\n  function Parser(handlers) {\n    this.handlers = handlers;\n    this.reset();\n  }\n  Parser.prototype.reset = function() {\n    return this.protocol = null;\n  };\n  Parser.prototype.process = function(data) {\n    var command, message, options, _ref;\n    try {\n      if (!(this.protocol != null)) {\n        if (data.match(/^!!ver:([\\d.]+)$/)) {\n          this.protocol = 6;\n        } else if (message = this._parseMessage(data, ['hello'])) {\n          if (!message.protocols.length) {\n            throw new ProtocolError(\"no protocols specified in handshake message\");\n          } else if (__indexOf.call(message.protocols, PROTOCOL_7) >= 0) {\n            this.protocol = 7;\n          } else if (__indexOf.call(message.protocols, PROTOCOL_6) >= 0) {\n            this.protocol = 6;\n          } else {\n            throw new ProtocolError(\"no supported protocols found\");\n          }\n        }\n        return this.handlers.connected(this.protocol);\n      } else if (this.protocol === 6) {\n        message = JSON.parse(data);\n        if (!message.length) {\n          throw new ProtocolError(\"protocol 6 messages must be arrays\");\n        }\n        command = message[0], options = message[1];\n        if (command !== 'refresh') {\n          throw new ProtocolError(\"unknown protocol 6 command\");\n        }\n        return this.handlers.message({\n          command: 'reload',\n          path: options.path,\n          liveCSS: (_ref = options.apply_css_live) != null ? _ref : true\n        });\n      } else {\n        message = this._parseMessage(data, ['reload', 'alert']);\n        return this.handlers.message(message);\n      }\n    } catch (e) {\n      if (e instanceof ProtocolError) {\n        return this.handlers.error(e);\n      } else {\n        throw e;\n      }\n    }\n  };\n  Parser.prototype._parseMessage = function(data, validCommands) {\n    var message, _ref;\n    try {\n      message = JSON.parse(data);\n    } catch (e) {\n      throw new ProtocolError('unparsable JSON', data);\n    }\n    if (!message.command) {\n      throw new ProtocolError('missing \"command\" key', data);\n    }\n    if (_ref = message.command, __indexOf.call(validCommands, _ref) < 0) {\n      throw new ProtocolError(\"invalid command '\" + message.command + \"', only valid commands are: \" + (validCommands.join(', ')) + \")\", data);\n    }\n    return message;\n  };\n  return Parser;\n})();\n\n// connector\n// Generated by CoffeeScript 1.3.3\nvar Connector, PROTOCOL_6, PROTOCOL_7, Parser, Version, _ref;\n\n_ref = __protocol, Parser = _ref.Parser, PROTOCOL_6 = _ref.PROTOCOL_6, PROTOCOL_7 = _ref.PROTOCOL_7;\n\nVersion = '2.0.8';\n\n__connector.Connector = Connector = (function() {\n\n  function Connector(options, WebSocket, Timer, handlers) {\n    var _this = this;\n    this.options = options;\n    this.WebSocket = WebSocket;\n    this.Timer = Timer;\n    this.handlers = handlers;\n    this._uri = \"ws://\" + this.options.host + \":\" + this.options.port + \"/livereload\";\n    this._nextDelay = this.options.mindelay;\n    this._connectionDesired = false;\n    this.protocol = 0;\n    this.protocolParser = new Parser({\n      connected: function(protocol) {\n        _this.protocol = protocol;\n        _this._handshakeTimeout.stop();\n        _this._nextDelay = _this.options.mindelay;\n        _this._disconnectionReason = 'broken';\n        return _this.handlers.connected(protocol);\n      },\n      error: function(e) {\n        _this.handlers.error(e);\n        return _this._closeOnError();\n      },\n      message: function(message) {\n        return _this.handlers.message(message);\n      }\n    });\n    this._handshakeTimeout = new Timer(function() {\n      if (!_this._isSocketConnected()) {\n        return;\n      }\n      _this._disconnectionReason = 'handshake-timeout';\n      return _this.socket.close();\n    });\n    this._reconnectTimer = new Timer(function() {\n      if (!_this._connectionDesired) {\n        return;\n      }\n      return _this.connect();\n    });\n    this.connect();\n  }\n\n  Connector.prototype._isSocketConnected = function() {\n    return this.socket && this.socket.readyState === this.WebSocket.OPEN;\n  };\n\n  Connector.prototype.connect = function() {\n    var _this = this;\n    this._connectionDesired = true;\n    if (this._isSocketConnected()) {\n      return;\n    }\n    this._reconnectTimer.stop();\n    this._disconnectionReason = 'cannot-connect';\n    this.protocolParser.reset();\n    this.handlers.connecting();\n    this.socket = new this.WebSocket(this._uri);\n    this.socket.onopen = function(e) {\n      return _this._onopen(e);\n    };\n    this.socket.onclose = function(e) {\n      return _this._onclose(e);\n    };\n    this.socket.onmessage = function(e) {\n      return _this._onmessage(e);\n    };\n    return this.socket.onerror = function(e) {\n      return _this._onerror(e);\n    };\n  };\n\n  Connector.prototype.disconnect = function() {\n    this._connectionDesired = false;\n    this._reconnectTimer.stop();\n    if (!this._isSocketConnected()) {\n      return;\n    }\n    this._disconnectionReason = 'manual';\n    return this.socket.close();\n  };\n\n  Connector.prototype._scheduleReconnection = function() {\n    if (!this._connectionDesired) {\n      return;\n    }\n    if (!this._reconnectTimer.running) {\n      this._reconnectTimer.start(this._nextDelay);\n      return this._nextDelay = Math.min(this.options.maxdelay, this._nextDelay * 2);\n    }\n  };\n\n  Connector.prototype.sendCommand = function(command) {\n    if (this.protocol == null) {\n      return;\n    }\n    return this._sendCommand(command);\n  };\n\n  Connector.prototype._sendCommand = function(command) {\n    return this.socket.send(JSON.stringify(command));\n  };\n\n  Connector.prototype._closeOnError = function() {\n    this._handshakeTimeout.stop();\n    this._disconnectionReason = 'error';\n    return this.socket.close();\n  };\n\n  Connector.prototype._onopen = function(e) {\n    var hello;\n    this.handlers.socketConnected();\n    this._disconnectionReason = 'handshake-failed';\n    hello = {\n      command: 'hello',\n      protocols: [PROTOCOL_6, PROTOCOL_7]\n    };\n    hello.ver = Version;\n    if (this.options.ext) {\n      hello.ext = this.options.ext;\n    }\n    if (this.options.extver) {\n      hello.extver = this.options.extver;\n    }\n    if (this.options.snipver) {\n      hello.snipver = this.options.snipver;\n    }\n    this._sendCommand(hello);\n    return this._handshakeTimeout.start(this.options.handshake_timeout);\n  };\n\n  Connector.prototype._onclose = function(e) {\n    this.protocol = 0;\n    this.handlers.disconnected(this._disconnectionReason, this._nextDelay);\n    return this._scheduleReconnection();\n  };\n\n  Connector.prototype._onerror = function(e) {};\n\n  Connector.prototype._onmessage = function(e) {\n    return this.protocolParser.process(e.data);\n  };\n\n  return Connector;\n\n})();\n\n// timer\nvar Timer;\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n__timer.Timer = Timer = (function() {\n  function Timer(func) {\n    this.func = func;\n    this.running = false;\n    this.id = null;\n    this._handler = __bind(function() {\n      this.running = false;\n      this.id = null;\n      return this.func();\n    }, this);\n  }\n  Timer.prototype.start = function(timeout) {\n    if (this.running) {\n      clearTimeout(this.id);\n    }\n    this.id = setTimeout(this._handler, timeout);\n    return this.running = true;\n  };\n  Timer.prototype.stop = function() {\n    if (this.running) {\n      clearTimeout(this.id);\n      this.running = false;\n      return this.id = null;\n    }\n  };\n  return Timer;\n})();\nTimer.start = function(timeout, func) {\n  return setTimeout(func, timeout);\n};\n\n// options\nvar Options;\n__options.Options = Options = (function() {\n  function Options() {\n    this.host = null;\n    this.port = 35729;\n    this.snipver = null;\n    this.ext = null;\n    this.extver = null;\n    this.mindelay = 1000;\n    this.maxdelay = 60000;\n    this.handshake_timeout = 5000;\n  }\n  Options.prototype.set = function(name, value) {\n    switch (typeof this[name]) {\n      case 'undefined':\n        break;\n      case 'number':\n        return this[name] = +value;\n      default:\n        return this[name] = value;\n    }\n  };\n  return Options;\n})();\nOptions.extract = function(document) {\n  var element, keyAndValue, m, mm, options, pair, src, _i, _j, _len, _len2, _ref, _ref2;\n  _ref = document.getElementsByTagName('script');\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    element = _ref[_i];\n    if ((src = element.src) && (m = src.match(/^[^:]+:\\/\\/(.*)\\/z?livereload\\.js(?:\\?(.*))?$/))) {\n      options = new Options();\n      if (mm = m[1].match(/^([^\\/:]+)(?::(\\d+))?$/)) {\n        options.host = mm[1];\n        if (mm[2]) {\n          options.port = parseInt(mm[2], 10);\n        }\n      }\n      if (m[2]) {\n        _ref2 = m[2].split('&');\n        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {\n          pair = _ref2[_j];\n          if ((keyAndValue = pair.split('=')).length > 1) {\n            options.set(keyAndValue[0].replace(/-/g, '_'), keyAndValue.slice(1).join('='));\n          }\n        }\n      }\n      return options;\n    }\n  }\n  return null;\n};\n\n// reloader\n// Generated by CoffeeScript 1.3.1\n(function() {\n  var IMAGE_STYLES, Reloader, numberOfMatchingSegments, pathFromUrl, pathsMatch, pickBestMatch, splitUrl;\n\n  splitUrl = function(url) {\n    var hash, index, params;\n    if ((index = url.indexOf('#')) >= 0) {\n      hash = url.slice(index);\n      url = url.slice(0, index);\n    } else {\n      hash = '';\n    }\n    if ((index = url.indexOf('?')) >= 0) {\n      params = url.slice(index);\n      url = url.slice(0, index);\n    } else {\n      params = '';\n    }\n    return {\n      url: url,\n      params: params,\n      hash: hash\n    };\n  };\n\n  pathFromUrl = function(url) {\n    var path;\n    url = splitUrl(url).url;\n    if (url.indexOf('file://') === 0) {\n      path = url.replace(/^file:\\/\\/(localhost)?/, '');\n    } else {\n      path = url.replace(/^([^:]+:)?\\/\\/([^:\\/]+)(:\\d*)?\\//, '/');\n    }\n    return decodeURIComponent(path);\n  };\n\n  pickBestMatch = function(path, objects, pathFunc) {\n    var bestMatch, object, score, _i, _len;\n    bestMatch = {\n      score: 0\n    };\n    for (_i = 0, _len = objects.length; _i < _len; _i++) {\n      object = objects[_i];\n      score = numberOfMatchingSegments(path, pathFunc(object));\n      if (score > bestMatch.score) {\n        bestMatch = {\n          object: object,\n          score: score\n        };\n      }\n    }\n    if (bestMatch.score > 0) {\n      return bestMatch;\n    } else {\n      return null;\n    }\n  };\n\n  numberOfMatchingSegments = function(path1, path2) {\n    var comps1, comps2, eqCount, len;\n    path1 = path1.replace(/^\\/+/, '').toLowerCase();\n    path2 = path2.replace(/^\\/+/, '').toLowerCase();\n    if (path1 === path2) {\n      return 10000;\n    }\n    comps1 = path1.split('/').reverse();\n    comps2 = path2.split('/').reverse();\n    len = Math.min(comps1.length, comps2.length);\n    eqCount = 0;\n    while (eqCount < len && comps1[eqCount] === comps2[eqCount]) {\n      ++eqCount;\n    }\n    return eqCount;\n  };\n\n  pathsMatch = function(path1, path2) {\n    return numberOfMatchingSegments(path1, path2) > 0;\n  };\n\n  IMAGE_STYLES = [\n    {\n      selector: 'background',\n      styleNames: ['backgroundImage']\n    }, {\n      selector: 'border',\n      styleNames: ['borderImage', 'webkitBorderImage', 'MozBorderImage']\n    }\n  ];\n\n  __reloader.Reloader = Reloader = (function() {\n\n    Reloader.name = 'Reloader';\n\n    function Reloader(window, console, Timer) {\n      this.window = window;\n      this.console = console;\n      this.Timer = Timer;\n      this.document = this.window.document;\n      this.importCacheWaitPeriod = 200;\n      this.plugins = [];\n    }\n\n    Reloader.prototype.addPlugin = function(plugin) {\n      return this.plugins.push(plugin);\n    };\n\n    Reloader.prototype.analyze = function(callback) {\n      return results;\n    };\n\n    Reloader.prototype.reload = function(path, options) {\n      var plugin, _base, _i, _len, _ref;\n      this.options = options;\n      if ((_base = this.options).stylesheetReloadTimeout == null) {\n        _base.stylesheetReloadTimeout = 15000;\n      }\n      _ref = this.plugins;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        plugin = _ref[_i];\n        if (plugin.reload && plugin.reload(path, options)) {\n          return;\n        }\n      }\n      if (options.liveCSS) {\n        if (path.match(/\\.css$/i)) {\n          if (this.reloadStylesheet(path)) {\n            return;\n          }\n        }\n      }\n      if (options.liveImg) {\n        if (path.match(/\\.(jpe?g|png|gif)$/i)) {\n          this.reloadImages(path);\n          return;\n        }\n      }\n      return this.reloadPage();\n    };\n\n    Reloader.prototype.reloadPage = function() {\n      return this.window.document.location.reload();\n    };\n\n    Reloader.prototype.reloadImages = function(path) {\n      var expando, img, selector, styleNames, styleSheet, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results;\n      expando = this.generateUniqueString();\n      _ref = this.document.images;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        img = _ref[_i];\n        if (pathsMatch(path, pathFromUrl(img.src))) {\n          img.src = this.generateCacheBustUrl(img.src, expando);\n        }\n      }\n      if (this.document.querySelectorAll) {\n        for (_j = 0, _len1 = IMAGE_STYLES.length; _j < _len1; _j++) {\n          _ref1 = IMAGE_STYLES[_j], selector = _ref1.selector, styleNames = _ref1.styleNames;\n          _ref2 = this.document.querySelectorAll(\"[style*=\" + selector + \"]\");\n          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n            img = _ref2[_k];\n            this.reloadStyleImages(img.style, styleNames, path, expando);\n          }\n        }\n      }\n      if (this.document.styleSheets) {\n        _ref3 = this.document.styleSheets;\n        _results = [];\n        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {\n          styleSheet = _ref3[_l];\n          _results.push(this.reloadStylesheetImages(styleSheet, path, expando));\n        }\n        return _results;\n      }\n    };\n\n    Reloader.prototype.reloadStylesheetImages = function(styleSheet, path, expando) {\n      var rule, rules, styleNames, _i, _j, _len, _len1;\n      try {\n        rules = styleSheet != null ? styleSheet.cssRules : void 0;\n      } catch (e) {\n\n      }\n      if (!rules) {\n        return;\n      }\n      for (_i = 0, _len = rules.length; _i < _len; _i++) {\n        rule = rules[_i];\n        switch (rule.type) {\n          case CSSRule.IMPORT_RULE:\n            this.reloadStylesheetImages(rule.styleSheet, path, expando);\n            break;\n          case CSSRule.STYLE_RULE:\n            for (_j = 0, _len1 = IMAGE_STYLES.length; _j < _len1; _j++) {\n              styleNames = IMAGE_STYLES[_j].styleNames;\n              this.reloadStyleImages(rule.style, styleNames, path, expando);\n            }\n            break;\n          case CSSRule.MEDIA_RULE:\n            this.reloadStylesheetImages(rule, path, expando);\n        }\n      }\n    };\n\n    Reloader.prototype.reloadStyleImages = function(style, styleNames, path, expando) {\n      var newValue, styleName, value, _i, _len,\n        _this = this;\n      for (_i = 0, _len = styleNames.length; _i < _len; _i++) {\n        styleName = styleNames[_i];\n        value = style[styleName];\n        if (typeof value === 'string') {\n          newValue = value.replace(/\\burl\\s*\\(([^)]*)\\)/, function(match, src) {\n            if (pathsMatch(path, pathFromUrl(src))) {\n              return \"url(\" + (_this.generateCacheBustUrl(src, expando)) + \")\";\n            } else {\n              return match;\n            }\n          });\n          if (newValue !== value) {\n            style[styleName] = newValue;\n          }\n        }\n      }\n    };\n\n    Reloader.prototype.reloadStylesheet = function(path) {\n      var imported, link, links, match, style, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1,\n        _this = this;\n      links = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.document.getElementsByTagName('link');\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          link = _ref[_i];\n          if (link.rel === 'stylesheet' && !link.__LiveReload_pendingRemoval) {\n            _results.push(link);\n          }\n        }\n        return _results;\n      }).call(this);\n      imported = [];\n      _ref = this.document.getElementsByTagName('style');\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        style = _ref[_i];\n        if (style.sheet) {\n          this.collectImportedStylesheets(style, style.sheet, imported);\n        }\n      }\n      for (_j = 0, _len1 = links.length; _j < _len1; _j++) {\n        link = links[_j];\n        this.collectImportedStylesheets(link, link.sheet, imported);\n      }\n      if (this.window.StyleFix && this.document.querySelectorAll) {\n        _ref1 = this.document.querySelectorAll('style[data-href]');\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          style = _ref1[_k];\n          links.push(style);\n        }\n      }\n      this.console.log(\"LiveReload found \" + links.length + \" LINKed stylesheets, \" + imported.length + \" @imported stylesheets\");\n      match = pickBestMatch(path, links.concat(imported), function(l) {\n        return pathFromUrl(_this.linkHref(l));\n      });\n      if (match) {\n        if (match.object.rule) {\n          this.console.log(\"LiveReload is reloading imported stylesheet: \" + match.object.href);\n          this.reattachImportedRule(match.object);\n        } else {\n          this.console.log(\"LiveReload is reloading stylesheet: \" + (this.linkHref(match.object)));\n          this.reattachStylesheetLink(match.object);\n        }\n      } else {\n        this.console.log(\"LiveReload will reload all stylesheets because path '\" + path + \"' did not match any specific one\");\n        for (_l = 0, _len3 = links.length; _l < _len3; _l++) {\n          link = links[_l];\n          this.reattachStylesheetLink(link);\n        }\n      }\n      return true;\n    };\n\n    Reloader.prototype.collectImportedStylesheets = function(link, styleSheet, result) {\n      var index, rule, rules, _i, _len;\n      try {\n        rules = styleSheet != null ? styleSheet.cssRules : void 0;\n      } catch (e) {\n\n      }\n      if (rules && rules.length) {\n        for (index = _i = 0, _len = rules.length; _i < _len; index = ++_i) {\n          rule = rules[index];\n          switch (rule.type) {\n            case CSSRule.CHARSET_RULE:\n              continue;\n            case CSSRule.IMPORT_RULE:\n              result.push({\n                link: link,\n                rule: rule,\n                index: index,\n                href: rule.href\n              });\n              this.collectImportedStylesheets(link, rule.styleSheet, result);\n              break;\n            default:\n              break;\n          }\n        }\n      }\n    };\n\n    Reloader.prototype.waitUntilCssLoads = function(clone, func) {\n      var callbackExecuted, executeCallback, poll,\n        _this = this;\n      callbackExecuted = false;\n      executeCallback = function() {\n        if (callbackExecuted) {\n          return;\n        }\n        callbackExecuted = true;\n        return func();\n      };\n      clone.onload = function() {\n        console.log(\"onload!\");\n        _this.knownToSupportCssOnLoad = true;\n        return executeCallback();\n      };\n      if (!this.knownToSupportCssOnLoad) {\n        (poll = function() {\n          if (clone.sheet) {\n            console.log(\"polling!\");\n            return executeCallback();\n          } else {\n            return _this.Timer.start(50, poll);\n          }\n        })();\n      }\n      return this.Timer.start(this.options.stylesheetReloadTimeout, executeCallback);\n    };\n\n    Reloader.prototype.linkHref = function(link) {\n      return link.href || link.getAttribute('data-href');\n    };\n\n    Reloader.prototype.reattachStylesheetLink = function(link) {\n      var clone, parent,\n        _this = this;\n      if (link.__LiveReload_pendingRemoval) {\n        return;\n      }\n      link.__LiveReload_pendingRemoval = true;\n      if (link.tagName === 'STYLE') {\n        clone = this.document.createElement('link');\n        clone.rel = 'stylesheet';\n        clone.media = link.media;\n        clone.disabled = link.disabled;\n      } else {\n        clone = link.cloneNode(false);\n      }\n      clone.href = this.generateCacheBustUrl(this.linkHref(link));\n      parent = link.parentNode;\n      if (parent.lastChild === link) {\n        parent.appendChild(clone);\n      } else {\n        parent.insertBefore(clone, link.nextSibling);\n      }\n      return this.waitUntilCssLoads(clone, function() {\n        var additionalWaitingTime;\n        if (/AppleWebKit/.test(navigator.userAgent)) {\n          additionalWaitingTime = 5;\n        } else {\n          additionalWaitingTime = 200;\n        }\n        return _this.Timer.start(additionalWaitingTime, function() {\n          var _ref;\n          if (!link.parentNode) {\n            return;\n          }\n          link.parentNode.removeChild(link);\n          clone.onreadystatechange = null;\n          return (_ref = _this.window.StyleFix) != null ? _ref.link(clone) : void 0;\n        });\n      });\n    };\n\n    Reloader.prototype.reattachImportedRule = function(_arg) {\n      var href, index, link, media, newRule, parent, rule, tempLink,\n        _this = this;\n      rule = _arg.rule, index = _arg.index, link = _arg.link;\n      parent = rule.parentStyleSheet;\n      href = this.generateCacheBustUrl(rule.href);\n      media = rule.media.length ? [].join.call(rule.media, ', ') : '';\n      newRule = \"@import url(\\\"\" + href + \"\\\") \" + media + \";\";\n      rule.__LiveReload_newHref = href;\n      tempLink = this.document.createElement(\"link\");\n      tempLink.rel = 'stylesheet';\n      tempLink.href = href;\n      tempLink.__LiveReload_pendingRemoval = true;\n      if (link.parentNode) {\n        link.parentNode.insertBefore(tempLink, link);\n      }\n      return this.Timer.start(this.importCacheWaitPeriod, function() {\n        if (tempLink.parentNode) {\n          tempLink.parentNode.removeChild(tempLink);\n        }\n        if (rule.__LiveReload_newHref !== href) {\n          return;\n        }\n        parent.insertRule(newRule, index);\n        parent.deleteRule(index + 1);\n        rule = parent.cssRules[index];\n        rule.__LiveReload_newHref = href;\n        return _this.Timer.start(_this.importCacheWaitPeriod, function() {\n          if (rule.__LiveReload_newHref !== href) {\n            return;\n          }\n          parent.insertRule(newRule, index);\n          return parent.deleteRule(index + 1);\n        });\n      });\n    };\n\n    Reloader.prototype.generateUniqueString = function() {\n      return 'livereload=' + Date.now();\n    };\n\n    Reloader.prototype.generateCacheBustUrl = function(url, expando) {\n      var hash, oldParams, params, _ref;\n      if (expando == null) {\n        expando = this.generateUniqueString();\n      }\n      _ref = splitUrl(url), url = _ref.url, hash = _ref.hash, oldParams = _ref.params;\n      if (this.options.overrideURL) {\n        if (url.indexOf(this.options.serverURL) < 0) {\n          url = this.options.serverURL + this.options.overrideURL + \"?url=\" + encodeURIComponent(url);\n        }\n      }\n      params = oldParams.replace(/(\\?|&)livereload=(\\d+)/, function(match, sep) {\n        return \"\" + sep + expando;\n      });\n      if (params === oldParams) {\n        if (oldParams.length === 0) {\n          params = \"?\" + expando;\n        } else {\n          params = \"\" + oldParams + \"&\" + expando;\n        }\n      }\n      return url + params + hash;\n    };\n\n    return Reloader;\n\n  })();\n\n}).call(this);\n\n// livereload\nvar Connector, LiveReload, Options, Reloader, Timer;\n\nConnector = __connector.Connector;\n\nTimer = __timer.Timer;\n\nOptions = __options.Options;\n\nReloader = __reloader.Reloader;\n\n__livereload.LiveReload = LiveReload = (function() {\n\n  function LiveReload(window) {\n    var _this = this;\n    this.window = window;\n    this.listeners = {};\n    this.plugins = [];\n    this.pluginIdentifiers = {};\n    this.console = this.window.location.href.match(/LR-verbose/) && this.window.console && this.window.console.log && this.window.console.error ? this.window.console : {\n      log: function() {},\n      error: function() {}\n    };\n    if (!(this.WebSocket = this.window.WebSocket || this.window.MozWebSocket)) {\n      console.error(\"LiveReload disabled because the browser does not seem to support web sockets\");\n      return;\n    }\n    if (!(this.options = Options.extract(this.window.document))) {\n      console.error(\"LiveReload disabled because it could not find its own <SCRIPT> tag\");\n      return;\n    }\n    this.reloader = new Reloader(this.window, this.console, Timer);\n    this.connector = new Connector(this.options, this.WebSocket, Timer, {\n      connecting: function() {},\n      socketConnected: function() {},\n      connected: function(protocol) {\n        var _base;\n        if (typeof (_base = _this.listeners).connect === \"function\") {\n          _base.connect();\n        }\n        _this.log(\"LiveReload is connected to \" + _this.options.host + \":\" + _this.options.port + \" (protocol v\" + protocol + \").\");\n        return _this.analyze();\n      },\n      error: function(e) {\n        if (e instanceof ProtocolError) {\n          return console.log(\"\" + e.message + \".\");\n        } else {\n          return console.log(\"LiveReload internal error: \" + e.message);\n        }\n      },\n      disconnected: function(reason, nextDelay) {\n        var _base;\n        if (typeof (_base = _this.listeners).disconnect === \"function\") {\n          _base.disconnect();\n        }\n        switch (reason) {\n          case 'cannot-connect':\n            return _this.log(\"LiveReload cannot connect to \" + _this.options.host + \":\" + _this.options.port + \", will retry in \" + nextDelay + \" sec.\");\n          case 'broken':\n            return _this.log(\"LiveReload disconnected from \" + _this.options.host + \":\" + _this.options.port + \", reconnecting in \" + nextDelay + \" sec.\");\n          case 'handshake-timeout':\n            return _this.log(\"LiveReload cannot connect to \" + _this.options.host + \":\" + _this.options.port + \" (handshake timeout), will retry in \" + nextDelay + \" sec.\");\n          case 'handshake-failed':\n            return _this.log(\"LiveReload cannot connect to \" + _this.options.host + \":\" + _this.options.port + \" (handshake failed), will retry in \" + nextDelay + \" sec.\");\n          case 'manual':\n            break;\n          case 'error':\n            break;\n          default:\n            return _this.log(\"LiveReload disconnected from \" + _this.options.host + \":\" + _this.options.port + \" (\" + reason + \"), reconnecting in \" + nextDelay + \" sec.\");\n        }\n      },\n      message: function(message) {\n        switch (message.command) {\n          case 'reload':\n            return _this.performReload(message);\n          case 'alert':\n            return _this.performAlert(message);\n        }\n      }\n    });\n  }\n\n  LiveReload.prototype.on = function(eventName, handler) {\n    return this.listeners[eventName] = handler;\n  };\n\n  LiveReload.prototype.log = function(message) {\n    return this.console.log(\"\" + message);\n  };\n\n  LiveReload.prototype.performReload = function(message) {\n    var _ref, _ref2;\n    this.log(\"LiveReload received reload request for \" + message.path + \".\");\n    return this.reloader.reload(message.path, {\n      liveCSS: (_ref = message.liveCSS) != null ? _ref : true,\n      liveImg: (_ref2 = message.liveImg) != null ? _ref2 : true,\n      originalPath: message.originalPath || '',\n      overrideURL: message.overrideURL || '',\n      serverURL: \"http://\" + this.options.host + \":\" + this.options.port\n    });\n  };\n\n  LiveReload.prototype.performAlert = function(message) {\n    return alert(message.message);\n  };\n\n  LiveReload.prototype.shutDown = function() {\n    var _base;\n    this.connector.disconnect();\n    this.log(\"LiveReload disconnected.\");\n    return typeof (_base = this.listeners).shutdown === \"function\" ? _base.shutdown() : void 0;\n  };\n\n  LiveReload.prototype.hasPlugin = function(identifier) {\n    return !!this.pluginIdentifiers[identifier];\n  };\n\n  LiveReload.prototype.addPlugin = function(pluginClass) {\n    var plugin;\n    var _this = this;\n    if (this.hasPlugin(pluginClass.identifier)) return;\n    this.pluginIdentifiers[pluginClass.identifier] = true;\n    plugin = new pluginClass(this.window, {\n      _livereload: this,\n      _reloader: this.reloader,\n      _connector: this.connector,\n      console: this.console,\n      Timer: Timer,\n      generateCacheBustUrl: function(url) {\n        return _this.reloader.generateCacheBustUrl(url);\n      }\n    });\n    this.plugins.push(plugin);\n    this.reloader.addPlugin(plugin);\n  };\n\n  LiveReload.prototype.analyze = function() {\n    var plugin, pluginData, pluginsData, _i, _len, _ref;\n    if (!(this.connector.protocol >= 7)) return;\n    pluginsData = {};\n    _ref = this.plugins;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      plugin = _ref[_i];\n      pluginsData[plugin.constructor.identifier] = pluginData = (typeof plugin.analyze === \"function\" ? plugin.analyze() : void 0) || {};\n      pluginData.version = plugin.constructor.version;\n    }\n    this.connector.sendCommand({\n      command: 'info',\n      plugins: pluginsData,\n      url: this.window.location.href\n    });\n  };\n\n  return LiveReload;\n\n})();\n\n// less\nvar LessPlugin;\n__less = LessPlugin = (function() {\n  LessPlugin.identifier = 'less';\n  LessPlugin.version = '1.0';\n  function LessPlugin(window, host) {\n    this.window = window;\n    this.host = host;\n  }\n  LessPlugin.prototype.reload = function(path, options) {\n    if (this.window.less && this.window.less.refresh) {\n      if (path.match(/\\.less$/i)) {\n        return this.reloadLess(path);\n      }\n      if (options.originalPath.match(/\\.less$/i)) {\n        return this.reloadLess(options.originalPath);\n      }\n    }\n    return false;\n  };\n  LessPlugin.prototype.reloadLess = function(path) {\n    var link, links, _i, _len;\n    links = (function() {\n      var _i, _len, _ref, _results;\n      _ref = document.getElementsByTagName('link');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        link = _ref[_i];\n        if (link.href && link.rel === 'stylesheet/less' || (link.rel.match(/stylesheet/) && link.type.match(/^text\\/(x-)?less$/))) {\n          _results.push(link);\n        }\n      }\n      return _results;\n    })();\n    if (links.length === 0) {\n      return false;\n    }\n    for (_i = 0, _len = links.length; _i < _len; _i++) {\n      link = links[_i];\n      link.href = this.host.generateCacheBustUrl(link.href);\n    }\n    this.host.console.log(\"LiveReload is asking LESS to recompile all stylesheets\");\n    this.window.less.refresh(true);\n    return true;\n  };\n  LessPlugin.prototype.analyze = function() {\n    return {\n      disable: !!(this.window.less && this.window.less.refresh)\n    };\n  };\n  return LessPlugin;\n})();\n\n// startup\nvar CustomEvents, LiveReload, k;\nCustomEvents = __customevents;\nLiveReload = window.LiveReload = new (__livereload.LiveReload)(window);\nfor (k in window) {\n  if (k.match(/^LiveReloadPlugin/)) {\n    LiveReload.addPlugin(window[k]);\n  }\n}\nLiveReload.addPlugin(__less);\nLiveReload.on('shutdown', function() {\n  return delete window.LiveReload;\n});\nLiveReload.on('connect', function() {\n  return CustomEvents.fire(document, 'LiveReloadConnect');\n});\nLiveReload.on('disconnect', function() {\n  return CustomEvents.fire(document, 'LiveReloadDisconnect');\n});\nCustomEvents.bind(document, 'LiveReloadShutDown', function() {\n  return LiveReload.shutDown();\n});\n})();\n"}